{"ast":null,"code":"module.exports.watch = watch;\nmodule.exports.resetWatchers = resetWatchers;\n\nvar debug = require('debug')('nodemon:watch');\n\nvar debugRoot = require('debug')('nodemon');\n\nvar chokidar = require('chokidar');\n\nvar undefsafe = require('undefsafe');\n\nvar config = require('../config');\n\nvar path = require('path');\n\nvar utils = require('../utils');\n\nvar bus = utils.bus;\n\nvar match = require('./match');\n\nvar watchers = [];\nvar debouncedBus;\nbus.on('reset', resetWatchers);\n\nfunction resetWatchers() {\n  debugRoot('resetting watchers');\n  watchers.forEach(function (watcher) {\n    watcher.close();\n  });\n  watchers = [];\n}\n\nfunction watch() {\n  if (watchers.length) {\n    debug('early exit on watch, still watching (%s)', watchers.length);\n    return;\n  }\n\n  var dirs = [].slice.call(config.dirs);\n  debugRoot('start watch on: %s', dirs.join(', '));\n  const rootIgnored = config.options.ignore;\n  debugRoot('ignored', rootIgnored);\n  var watchedFiles = [];\n  const promise = new Promise(function (resolve) {\n    const dotFilePattern = /[/\\\\]\\./;\n    var ignored = match.rulesToMonitor([], // not needed\n    Array.from(rootIgnored), config).map(pattern => pattern.slice(1));\n    const addDotFile = dirs.filter(dir => dir.match(dotFilePattern)); // don't ignore dotfiles if explicitly watched.\n\n    if (addDotFile.length === 0) {\n      ignored.push(dotFilePattern);\n    }\n\n    var watchOptions = {\n      ignorePermissionErrors: true,\n      ignored: ignored,\n      persistent: true,\n      usePolling: config.options.legacyWatch || false,\n      interval: config.options.pollingInterval // note to future developer: I've gone back and forth on adding `cwd`\n      // to the props and in some cases it fixes bugs but typically it causes\n      // bugs elsewhere (since nodemon is used is so many ways). the final\n      // decision is to *not* use it at all and work around it\n      // cwd: ...\n\n    };\n\n    if (utils.isWindows) {\n      watchOptions.disableGlobbing = true;\n    }\n\n    if (process.env.TEST) {\n      watchOptions.useFsEvents = false;\n    }\n\n    var watcher = chokidar.watch(dirs, Object.assign({}, watchOptions, config.options.watchOptions || {}));\n    watcher.ready = false;\n    var total = 0;\n    watcher.on('change', filterAndRestart);\n    watcher.on('add', function (file) {\n      if (watcher.ready) {\n        return filterAndRestart(file);\n      }\n\n      watchedFiles.push(file);\n      bus.emit('watching', file);\n      debug('chokidar watching: %s', file);\n    });\n    watcher.on('ready', function () {\n      watchedFiles = Array.from(new Set(watchedFiles)); // ensure no dupes\n\n      total = watchedFiles.length;\n      watcher.ready = true;\n      resolve(total);\n      debugRoot('watch is complete');\n    });\n    watcher.on('error', function (error) {\n      if (error.code === 'EINVAL') {\n        utils.log.error('Internal watch failed. Likely cause: too many ' + 'files being watched (perhaps from the root of a drive?\\n' + 'See https://github.com/paulmillr/chokidar/issues/229 for details');\n      } else {\n        utils.log.error('Internal watch failed: ' + error.message);\n        process.exit(1);\n      }\n    });\n    watchers.push(watcher);\n  });\n  return promise.catch(e => {\n    // this is a core error and it should break nodemon - so I have to break\n    // out of a promise using the setTimeout\n    setTimeout(() => {\n      throw e;\n    });\n  }).then(function () {\n    utils.log.detail(\"watching \".concat(watchedFiles.length, \" file\").concat(watchedFiles.length === 1 ? '' : 's'));\n    return watchedFiles;\n  });\n}\n\nfunction filterAndRestart(files) {\n  if (!Array.isArray(files)) {\n    files = [files];\n  }\n\n  if (files.length) {\n    var cwd = process.cwd();\n\n    if (this.options && this.options.cwd) {\n      cwd = this.options.cwd;\n    }\n\n    utils.log.detail('files triggering change check: ' + files.map(file => {\n      const res = path.relative(cwd, file);\n      return res;\n    }).join(', ')); // make sure the path is right and drop an empty\n    // filenames (sometimes on windows)\n\n    files = files.filter(Boolean).map(file => {\n      return path.relative(process.cwd(), path.relative(cwd, file));\n    });\n\n    if (utils.isWindows) {\n      // ensure the drive letter is in uppercase (c:\\foo -> C:\\foo)\n      files = files.map(f => {\n        if (f.indexOf(':') === -1) {\n          return f;\n        }\n\n        return f[0].toUpperCase() + f.slice(1);\n      });\n    }\n\n    debug('filterAndRestart on', files);\n    var matched = match(files, config.options.monitor, undefsafe(config, 'options.execOptions.ext'));\n    debug('matched?', JSON.stringify(matched)); // if there's no matches, then test to see if the changed file is the\n    // running script, if so, let's allow a restart\n\n    if (config.options.execOptions.script) {\n      const script = path.resolve(config.options.execOptions.script);\n\n      if (matched.result.length === 0 && script) {\n        const length = script.length;\n        files.find(file => {\n          if (file.substr(-length, length) === script) {\n            matched = {\n              result: [file],\n              total: 1\n            };\n            return true;\n          }\n        });\n      }\n    }\n\n    utils.log.detail('changes after filters (before/after): ' + [files.length, matched.result.length].join('/')); // reset the last check so we're only looking at recently modified files\n\n    config.lastStarted = Date.now();\n\n    if (matched.result.length) {\n      if (config.options.delay > 0) {\n        utils.log.detail('delaying restart for ' + config.options.delay + 'ms');\n\n        if (debouncedBus === undefined) {\n          debouncedBus = debounce(restartBus, config.options.delay);\n        }\n\n        debouncedBus(matched);\n      } else {\n        return restartBus(matched);\n      }\n    }\n  }\n}\n\nfunction restartBus(matched) {\n  utils.log.status('restarting due to changes...');\n  matched.result.map(file => {\n    utils.log.detail(path.relative(process.cwd(), file));\n  });\n\n  if (config.options.verbose) {\n    utils.log._log('');\n  }\n\n  bus.emit('restart', matched.result);\n}\n\nfunction debounce(fn, delay) {\n  var timer = null;\n  return function () {\n    const context = this;\n    const args = arguments;\n    clearTimeout(timer);\n    timer = setTimeout(() => fn.apply(context, args), delay);\n  };\n}","map":null,"metadata":{},"sourceType":"script"}