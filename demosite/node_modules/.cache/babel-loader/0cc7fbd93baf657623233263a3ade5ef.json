{"ast":null,"code":"var debug = require('debug')('nodemon');\n\nvar path = require('path');\n\nvar monitor = require('./monitor');\n\nvar cli = require('./cli');\n\nvar version = require('./version');\n\nvar util = require('util');\n\nvar utils = require('./utils');\n\nvar bus = utils.bus;\n\nvar help = require('./help');\n\nvar config = require('./config');\n\nvar spawn = require('./spawn');\n\nconst defaults = require('./config/defaults');\n\nvar eventHandlers = {}; // this is fairly dirty, but theoretically sound since it's part of the\n// stable module API\n\nconfig.required = utils.isRequired;\n\nfunction nodemon(settings) {\n  bus.emit('boot');\n  nodemon.reset(); // allow the cli string as the argument to nodemon, and allow for\n  // `node nodemon -V app.js` or just `-V app.js`\n\n  if (typeof settings === 'string') {\n    settings = settings.trim();\n\n    if (settings.indexOf('node') !== 0) {\n      if (settings.indexOf('nodemon') !== 0) {\n        settings = 'nodemon ' + settings;\n      }\n\n      settings = 'node ' + settings;\n    }\n\n    settings = cli.parse(settings);\n  } // set the debug flag as early as possible to get all the detailed logging\n\n\n  if (settings.verbose) {\n    utils.debug = true;\n  }\n\n  if (settings.help) {\n    process.stdout._handle.setBlocking(true); // nodejs/node#6456\n\n\n    console.log(help(settings.help));\n\n    if (!config.required) {\n      process.exit(0);\n    }\n  }\n\n  if (settings.version) {\n    version().then(function (v) {\n      console.log(v);\n\n      if (!config.required) {\n        process.exit(0);\n      }\n    });\n    return;\n  } // nodemon tools like grunt-nodemon. This affects where\n  // the script is being run from, and will affect where\n  // nodemon looks for the nodemon.json files\n\n\n  if (settings.cwd) {\n    // this is protection to make sure we haven't dont the chdir already...\n    // say like in cli/parse.js (which is where we do this once already!)\n    if (process.cwd() !== path.resolve(config.system.cwd, settings.cwd)) {\n      process.chdir(settings.cwd);\n    }\n  }\n\n  const cwd = process.cwd();\n  config.load(settings, function (config) {\n    if (!config.options.dump && !config.options.execOptions.script && config.options.execOptions.exec === 'node') {\n      if (!config.required) {\n        console.log(help('usage'));\n        process.exit();\n      }\n\n      return;\n    } // before we print anything, update the colour setting on logging\n\n\n    utils.colours = config.options.colours; // always echo out the current version\n\n    utils.log.info(version.pinned);\n    const cwd = process.cwd();\n\n    if (config.options.cwd) {\n      utils.log.detail('process root: ' + cwd);\n    }\n\n    config.loaded.map(file => file.replace(cwd, '.')).forEach(file => {\n      utils.log.detail('reading config ' + file);\n    });\n\n    if (config.options.stdin && config.options.restartable) {\n      // allow nodemon to restart when the use types 'rs\\n'\n      process.stdin.resume();\n      process.stdin.setEncoding('utf8');\n      process.stdin.on('data', data => {\n        const str = data.toString().trim().toLowerCase(); // if the keys entered match the restartable value, then restart!\n\n        if (str === config.options.restartable) {\n          bus.emit('restart');\n        } else if (data.charCodeAt(0) === 12) {\n          // ctrl+l\n          console.clear();\n        }\n      });\n    } else if (config.options.stdin) {\n      // so let's make sure we don't eat the key presses\n      // but also, since we're wrapping, watch out for\n      // special keys, like ctrl+c x 2 or '.exit' or ctrl+d or ctrl+l\n      var ctrlC = false;\n      var buffer = '';\n      process.stdin.on('data', function (data) {\n        data = data.toString();\n        buffer += data;\n        const chr = data.charCodeAt(0); // if restartable, echo back\n\n        if (chr === 3) {\n          if (ctrlC) {\n            process.exit(0);\n          }\n\n          ctrlC = true;\n          return;\n        } else if (buffer === '.exit' || chr === 4) {\n          // ctrl+d\n          process.exit();\n        } else if (chr === 13 || chr === 10) {\n          // enter / carriage return\n          buffer = '';\n        } else if (chr === 12) {\n          // ctrl+l\n          console.clear();\n          buffer = '';\n        }\n\n        ctrlC = false;\n      });\n\n      if (process.stdin.setRawMode) {\n        process.stdin.setRawMode(true);\n      }\n    }\n\n    if (config.options.restartable) {\n      utils.log.info('to restart at any time, enter `' + config.options.restartable + '`');\n    }\n\n    if (!config.required) {\n      const restartSignal = config.options.signal === 'SIGUSR2' ? 'SIGHUP' : 'SIGUSR2';\n      process.on(restartSignal, nodemon.restart);\n      utils.bus.on('error', () => {\n        utils.log.fail(new Error().stack);\n      });\n      utils.log.detail((config.options.restartable ? 'or ' : '') + 'send ' + restartSignal + ' to ' + process.pid + ' to restart');\n    }\n\n    const ignoring = config.options.monitor.map(function (rule) {\n      if (rule.slice(0, 1) !== '!') {\n        return false;\n      }\n\n      rule = rule.slice(1); // don't notify of default ignores\n\n      if (defaults.ignoreRoot.indexOf(rule) !== -1) {\n        return false;\n        return rule.slice(3).slice(0, -3);\n      }\n\n      if (rule.startsWith(cwd)) {\n        return rule.replace(cwd, '.');\n      }\n\n      return rule;\n    }).filter(Boolean).join(' ');\n    if (ignoring) utils.log.detail('ignoring: ' + ignoring);\n    utils.log.info('watching dir(s): ' + config.options.monitor.map(function (rule) {\n      if (rule.slice(0, 1) !== '!') {\n        try {\n          rule = path.relative(process.cwd(), rule);\n        } catch (e) {}\n\n        return rule;\n      }\n\n      return false;\n    }).filter(Boolean).join(' '));\n    utils.log.info('watching extensions: ' + (config.options.execOptions.ext || '(all)'));\n\n    if (config.options.dump) {\n      utils.log._log('log', '--------------');\n\n      utils.log._log('log', 'node: ' + process.version);\n\n      utils.log._log('log', 'nodemon: ' + version.pinned);\n\n      utils.log._log('log', 'command: ' + process.argv.join(' '));\n\n      utils.log._log('log', 'cwd: ' + cwd);\n\n      utils.log._log('log', ['OS:', process.platform, process.arch].join(' '));\n\n      utils.log._log('log', '--------------');\n\n      utils.log._log('log', util.inspect(config, {\n        depth: null\n      }));\n\n      utils.log._log('log', '--------------');\n\n      if (!config.required) {\n        process.exit();\n      }\n\n      return;\n    }\n\n    config.run = true;\n\n    if (config.options.stdout === false) {\n      nodemon.on('start', function () {\n        nodemon.stdout = bus.stdout;\n        nodemon.stderr = bus.stderr;\n        bus.emit('readable');\n      });\n    }\n\n    if (config.options.events && Object.keys(config.options.events).length) {\n      Object.keys(config.options.events).forEach(function (key) {\n        utils.log.detail('bind ' + key + ' -> `' + config.options.events[key] + '`');\n        nodemon.on(key, function () {\n          if (config.options && config.options.events) {\n            spawn(config.options.events[key], config, [].slice.apply(arguments));\n          }\n        });\n      });\n    }\n\n    monitor.run(config.options);\n  });\n  return nodemon;\n}\n\nnodemon.restart = function () {\n  utils.log.status('restarting child process');\n  bus.emit('restart');\n  return nodemon;\n};\n\nnodemon.addListener = nodemon.on = function (event, handler) {\n  if (!eventHandlers[event]) {\n    eventHandlers[event] = [];\n  }\n\n  eventHandlers[event].push(handler);\n  bus.on(event, handler);\n  return nodemon;\n};\n\nnodemon.once = function (event, handler) {\n  if (!eventHandlers[event]) {\n    eventHandlers[event] = [];\n  }\n\n  eventHandlers[event].push(handler);\n  bus.once(event, function () {\n    debug('bus.once(%s)', event);\n    eventHandlers[event].splice(eventHandlers[event].indexOf(handler), 1);\n    handler.apply(this, arguments);\n  });\n  return nodemon;\n};\n\nnodemon.emit = function () {\n  bus.emit.apply(bus, [].slice.call(arguments));\n  return nodemon;\n};\n\nnodemon.removeAllListeners = function (event) {\n  // unbind only the `nodemon.on` event handlers\n  Object.keys(eventHandlers).filter(function (e) {\n    return event ? e === event : true;\n  }).forEach(function (event) {\n    eventHandlers[event].forEach(function (handler) {\n      bus.removeListener(event, handler);\n      eventHandlers[event].splice(eventHandlers[event].indexOf(handler), 1);\n    });\n  });\n  return nodemon;\n};\n\nnodemon.reset = function (done) {\n  bus.emit('reset', done);\n};\n\nbus.on('reset', function (done) {\n  debug('reset');\n  nodemon.removeAllListeners();\n  monitor.run.kill(true, function () {\n    utils.reset();\n    config.reset();\n    config.run = false;\n\n    if (done) {\n      done();\n    }\n  });\n}); // expose the full config\n\nnodemon.config = config;\nmodule.exports = nodemon;","map":null,"metadata":{},"sourceType":"script"}