{"ast":null,"code":"const minimatch = require('minimatch');\n\nconst path = require('path');\n\nconst fs = require('fs');\n\nconst debug = require('debug')('nodemon:match');\n\nconst utils = require('../utils');\n\nmodule.exports = match;\nmodule.exports.rulesToMonitor = rulesToMonitor;\n\nfunction rulesToMonitor(watch, ignore, config) {\n  var monitor = [];\n\n  if (!Array.isArray(ignore)) {\n    if (ignore) {\n      ignore = [ignore];\n    } else {\n      ignore = [];\n    }\n  }\n\n  if (!Array.isArray(watch)) {\n    if (watch) {\n      watch = [watch];\n    } else {\n      watch = [];\n    }\n  }\n\n  if (watch && watch.length) {\n    monitor = utils.clone(watch);\n  }\n\n  if (ignore) {\n    [].push.apply(monitor, (ignore || []).map(function (rule) {\n      return '!' + rule;\n    }));\n  }\n\n  var cwd = process.cwd(); // next check if the monitored paths are actual directories\n  // or just patterns - and expand the rule to include *.*\n\n  monitor = monitor.map(function (rule) {\n    var not = rule.slice(0, 1) === '!';\n\n    if (not) {\n      rule = rule.slice(1);\n    }\n\n    if (rule === '.' || rule === '.*') {\n      rule = '*.*';\n    }\n\n    var dir = path.resolve(cwd, rule);\n\n    try {\n      var stat = fs.statSync(dir);\n\n      if (stat.isDirectory()) {\n        rule = dir;\n\n        if (rule.slice(-1) !== '/') {\n          rule += '/';\n        }\n\n        rule += '**/*'; // `!not` ... sorry.\n\n        if (!not) {\n          config.dirs.push(dir);\n        }\n      } else {\n        // ensures we end up in the check that tries to get a base directory\n        // and then adds it to the watch list\n        throw new Error();\n      }\n    } catch (e) {\n      var base = tryBaseDir(dir);\n\n      if (!not && base) {\n        if (config.dirs.indexOf(base) === -1) {\n          config.dirs.push(base);\n        }\n      }\n    }\n\n    if (rule.slice(-1) === '/') {\n      // just slap on a * anyway\n      rule += '*';\n    } // if the url ends with * but not **/* and not *.*\n    // then convert to **/* - somehow it was missed :-\\\n\n\n    if (rule.slice(-4) !== '**/*' && rule.slice(-1) === '*' && rule.indexOf('*.') === -1) {\n      if (rule.slice(-2) !== '**') {\n        rule += '*/*';\n      }\n    }\n\n    return (not ? '!' : '') + rule;\n  });\n  return monitor;\n}\n\nfunction tryBaseDir(dir) {\n  var stat;\n\n  if (/[?*\\{\\[]+/.test(dir)) {\n    // if this is pattern, then try to find the base\n    try {\n      var base = path.dirname(dir.replace(/([?*\\{\\[]+.*$)/, 'foo'));\n      stat = fs.statSync(base);\n\n      if (stat.isDirectory()) {\n        return base;\n      }\n    } catch (error) {// console.log(error);\n    }\n  } else {\n    try {\n      stat = fs.statSync(dir); // if this path is actually a single file that exists, then just monitor\n      // that, *specifically*.\n\n      if (stat.isFile() || stat.isDirectory()) {\n        return dir;\n      }\n    } catch (e) {}\n  }\n\n  return false;\n}\n\nfunction match(files, monitor, ext) {\n  // sort the rules by highest specificity (based on number of slashes)\n  // ignore rules (!) get sorted highest as they take precedent\n  const cwd = process.cwd();\n  var rules = monitor.sort(function (a, b) {\n    var r = b.split(path.sep).length - a.split(path.sep).length;\n    var aIsIgnore = a.slice(0, 1) === '!';\n    var bIsIgnore = b.slice(0, 1) === '!';\n\n    if (aIsIgnore || bIsIgnore) {\n      if (aIsIgnore) {\n        return -1;\n      }\n\n      return 1;\n    }\n\n    if (r === 0) {\n      return b.length - a.length;\n    }\n\n    return r;\n  }).map(function (s) {\n    var prefix = s.slice(0, 1);\n\n    if (prefix === '!') {\n      if (s.indexOf('!' + cwd) === 0) {\n        return s;\n      }\n\n      return '!**' + (prefix !== path.sep ? path.sep : '') + s.slice(1);\n    } // if it starts with a period, then let's get the relative path\n\n\n    if (s.indexOf('.') === 0) {\n      return path.resolve(cwd, s);\n    }\n\n    if (s.indexOf(cwd) === 0) {\n      return s;\n    }\n\n    return '**' + (prefix !== path.sep ? path.sep : '') + s;\n  });\n  debug('rules', rules);\n  var good = [];\n  var whitelist = []; // files that we won't check against the extension\n\n  var ignored = 0;\n  var watched = 0;\n  var usedRules = [];\n  var minimatchOpts = {\n    dot: true\n  }; // enable case-insensitivity on Windows\n\n  if (utils.isWindows) {\n    minimatchOpts.nocase = true;\n  }\n\n  files.forEach(function (file) {\n    file = path.resolve(cwd, file);\n    var matched = false;\n\n    for (var i = 0; i < rules.length; i++) {\n      if (rules[i].slice(0, 1) === '!') {\n        if (!minimatch(file, rules[i], minimatchOpts)) {\n          ignored++;\n          matched = true;\n          break;\n        }\n      } else {\n        debug('match', file, minimatch(file, rules[i], minimatchOpts));\n\n        if (minimatch(file, rules[i], minimatchOpts)) {\n          watched++; // don't repeat the output if a rule is matched\n\n          if (usedRules.indexOf(rules[i]) === -1) {\n            usedRules.push(rules[i]);\n            utils.log.detail('matched rule: ' + rules[i]);\n          } // if the rule doesn't match the WATCH EVERYTHING\n          // but *does* match a rule that ends with *.*, then\n          // white list it - in that we don't run it through\n          // the extension check too.\n\n\n          if (rules[i] !== '**' + path.sep + '*.*' && rules[i].slice(-3) === '*.*') {\n            whitelist.push(file);\n          } else if (path.basename(file) === path.basename(rules[i])) {\n            // if the file matches the actual rule, then it's put on whitelist\n            whitelist.push(file);\n          } else {\n            good.push(file);\n          }\n\n          matched = true;\n          break;\n        } else {// utils.log.detail('no match: ' + rules[i], file);\n        }\n      }\n    }\n\n    if (!matched) {\n      ignored++;\n    }\n  });\n  debug('good', good); // finally check the good files against the extensions that we're monitoring\n\n  if (ext) {\n    if (ext.indexOf(',') === -1) {\n      ext = '**/*.' + ext;\n    } else {\n      ext = '**/*.{' + ext + '}';\n    }\n\n    good = good.filter(function (file) {\n      // only compare the filename to the extension test\n      return minimatch(path.basename(file), ext, minimatchOpts);\n    });\n  } // else assume *.*\n\n\n  var result = good.concat(whitelist);\n\n  if (utils.isWindows) {\n    // fix for windows testing - I *think* this is okay to do\n    result = result.map(function (file) {\n      return file.slice(0, 1).toLowerCase() + file.slice(1);\n    });\n  }\n\n  return {\n    result: result,\n    ignored: ignored,\n    watched: watched,\n    total: files.length\n  };\n}","map":null,"metadata":{},"sourceType":"script"}