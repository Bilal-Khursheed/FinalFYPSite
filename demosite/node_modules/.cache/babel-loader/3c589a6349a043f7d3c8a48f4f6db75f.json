{"ast":null,"code":"import _inheritsLoose from '@babel/runtime/helpers/inheritsLoose';\nimport _objectWithoutPropertiesLoose from '@babel/runtime/helpers/objectWithoutPropertiesLoose';\nimport _extends from '@babel/runtime/helpers/extends';\nimport React, { Fragment } from 'react';\nimport _regeneratorRuntime from '@babel/runtime/regenerator';\nimport _asyncToGenerator from '@babel/runtime/helpers/asyncToGenerator';\nimport BlobStream from 'blob-stream';\nimport ReactFiberReconciler from 'react-reconciler';\nimport { unstable_scheduleCallback, unstable_cancelCallback } from 'scheduler';\nimport _createClass from '@babel/runtime/helpers/createClass';\nimport PDFDocument, { PDFFont } from '@react-pdf/pdfkit';\nimport Yoga from 'yoga-layout-prebuilt';\nimport { mergeDeepWith, isNil, compose, equals, type, toPairsIn, pick, pathOr, last, propEq, complement, prop } from 'ramda';\nimport matchMedia from 'media-engine';\nimport _assertThisInitialized from '@babel/runtime/helpers/assertThisInitialized';\nimport PDFRenderer$1 from '@react-pdf/textkit/renderers/pdf';\nimport AttributedString from '@react-pdf/textkit/attributedString';\nimport 'is-url';\nimport fontkit from '@react-pdf/fontkit';\nimport fetch from 'cross-fetch';\nimport layoutEngine from '@react-pdf/textkit/layout';\nimport linebreaker from '@react-pdf/textkit/engines/linebreaker';\nimport justification from '@react-pdf/textkit/engines/justification';\nimport textDecoration from '@react-pdf/textkit/engines/textDecoration';\nimport scriptItemizer from '@react-pdf/textkit/engines/scriptItemizer';\nimport wordHyphenation from '@react-pdf/textkit/engines/wordHyphenation';\nimport emojiRegex from 'emoji-regex';\nimport PNG from '@react-pdf/png-js';\nimport _wrapPages from 'page-wrapping';\n\nfunction printWarning(format) {\n  for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n    args[_key - 1] = arguments[_key];\n  }\n\n  var argIndex = 0;\n  var message = 'Warning: ' + format.replace(/%s/g, function () {\n    return args[argIndex++];\n  });\n\n  if (typeof console !== 'undefined') {\n    console.error(message);\n  }\n\n  try {\n    throw new Error(message);\n  } catch (x) {}\n}\n\nvar __DEV__ = process.env.NODE_ENV !== 'production';\n\nvar warning = __DEV__ ? function (condition, format) {\n  if (format === undefined) {\n    throw new Error('`warning(condition, format, ...args)` requires a warning ' + 'message argument');\n  }\n\n  if (!condition) {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 2 ? _len2 - 2 : 0), _key2 = 2; _key2 < _len2; _key2++) {\n      args[_key2 - 2] = arguments[_key2];\n    }\n\n    printWarning.apply(void 0, [format].concat(args));\n  }\n} : function () {};\n\nvar Root =\n/*#__PURE__*/\nfunction () {\n  function Root() {\n    this.isDirty = false;\n    this.document = null;\n    this.instance = null;\n  }\n\n  var _proto = Root.prototype;\n\n  _proto.appendChild = function appendChild(child) {\n    this.document = child;\n  };\n\n  _proto.removeChild = function removeChild() {\n    this.document.cleanup();\n    this.document = null;\n  };\n\n  _proto.markDirty = function markDirty() {\n    this.isDirty = true;\n  };\n\n  _proto.cleanup = function cleanup() {\n    this.document.cleanup();\n  };\n\n  _proto.finish = function finish() {\n    this.document.finish();\n  };\n\n  _proto.render =\n  /*#__PURE__*/\n  function () {\n    var _render = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this.instance = new PDFDocument({\n                autoFirstPage: false\n              });\n              _context.next = 3;\n              return this.document.render();\n\n            case 3:\n              this.cleanup();\n              this.isDirty = false;\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function render() {\n      return _render.apply(this, arguments);\n    }\n\n    return render;\n  }();\n\n  _createClass(Root, [{\n    key: \"name\",\n    get: function get() {\n      return 'Root';\n    }\n  }]);\n\n  return Root;\n}();\n\nvar upperFirst = function upperFirst(value) {\n  return value.charAt(0).toUpperCase() + value.slice(1);\n};\n\nvar isPercent = function isPercent(value) {\n  return /((-)?\\d+\\.?\\d*)%/g.exec(value);\n};\n\nvar matchPercent = function matchPercent(value) {\n  var match = isPercent(value);\n\n  if (match) {\n    var _value = parseFloat(match[1], 10);\n\n    var percent = _value / 100;\n    return {\n      value: _value,\n      percent: percent,\n      absValue: Math.abs(_value),\n      absPercent: Math.abs(percent)\n    };\n  }\n\n  return null;\n};\n\nvar YOGA_CONFIG = Yoga.Config.create();\nYOGA_CONFIG.setPointScaleFactor(0);\n\nvar Node =\n/*#__PURE__*/\nfunction () {\n  function Node() {\n    this.parent = null;\n    this.children = [];\n    this.computed = false;\n    this.layout = Yoga.Node.createWithConfig(YOGA_CONFIG);\n  }\n\n  var _proto = Node.prototype;\n\n  _proto.appendChild = function appendChild(child) {\n    if (child) {\n      child.parent = this;\n      this.children.push(child);\n      this.layout.insertChild(child.layout, this.layout.getChildCount());\n    }\n  };\n\n  _proto.appendChildBefore = function appendChildBefore(child, beforeChild) {\n    var index = this.children.indexOf(beforeChild);\n\n    if (index !== -1 && child) {\n      child.parent = this;\n      this.children.splice(index, 0, child);\n      this.layout.insertChild(child.layout, index);\n    }\n  };\n\n  _proto.removeChild = function removeChild(child) {\n    var index = this.children.indexOf(child);\n\n    if (index !== -1) {\n      child.parent = null;\n      this.children.splice(index, 1);\n      this.layout.removeChild(child.layout);\n    }\n\n    child.cleanup();\n  };\n\n  _proto.removeAllChilds = function removeAllChilds() {\n    var children = [].concat(this.children);\n\n    for (var i = 0; i < children.length; i++) {\n      children[i].remove();\n    }\n  };\n\n  _proto.remove = function remove() {\n    this.parent.removeChild(this);\n  };\n\n  _proto.setDimension = function setDimension(attr, value) {\n    var fixedMethod = \"set\" + upperFirst(attr);\n    var percentMethod = fixedMethod + \"Percent\";\n    var percent = matchPercent(value);\n\n    if (percent) {\n      this.layout[percentMethod](percent.value);\n    } else {\n      this.layout[fixedMethod](value);\n    }\n  };\n\n  _proto.setPosition = function setPosition(edge, value) {\n    var percent = matchPercent(value);\n\n    if (percent) {\n      this.layout.setPositionPercent(edge, percent.value);\n    } else {\n      this.layout.setPosition(edge, value);\n    }\n  };\n\n  _proto.setPadding = function setPadding(edge, value) {\n    var percent = matchPercent(value);\n\n    if (percent) {\n      this.layout.setPaddingPercent(edge, percent.value);\n    } else {\n      this.layout.setPadding(edge, value);\n    }\n  };\n\n  _proto.setMargin = function setMargin(edge, value) {\n    var percent = matchPercent(value);\n\n    if (percent) {\n      this.layout.setMarginPercent(edge, percent.value);\n    } else {\n      this.layout.setMargin(edge, value);\n    }\n  };\n\n  _proto.setBorder = function setBorder(edge, value) {\n    if (matchPercent(value)) {\n      throw new Error('Node: You cannot set percentage border widths');\n    }\n\n    this.layout.setBorder(edge, value);\n  };\n\n  _proto.getAbsoluteLayout = function getAbsoluteLayout() {\n    var parent = this.parent;\n    var parentLayout = parent && parent.getAbsoluteLayout ? parent.getAbsoluteLayout() : {\n      left: 0,\n      top: 0\n    };\n    return {\n      left: this.left + parentLayout.left,\n      top: this.top + parentLayout.top,\n      height: this.height,\n      width: this.width\n    };\n  };\n\n  _proto.copyStyle = function copyStyle(node) {\n    this.layout.copyStyle(node.layout);\n  };\n\n  _proto.calculateLayout = function calculateLayout() {\n    this.layout.calculateLayout();\n    this.computed = true;\n  };\n\n  _proto.isEmpty = function isEmpty() {\n    return this.children.length === 0;\n  };\n\n  _proto.markDirty = function markDirty() {\n    return this.layout.markDirty();\n  };\n\n  _proto.onAppendDynamically = function onAppendDynamically() {};\n\n  _proto.cleanup = function cleanup() {\n    this.children.forEach(function (c) {\n      return c.cleanup();\n    });\n    this.layout.unsetMeasureFunc();\n    Yoga.Node.destroy(this.layout);\n  };\n\n  _createClass(Node, [{\n    key: \"position\",\n    get: function get() {\n      return this.layout.getPositionType() === Yoga.POSITION_TYPE_ABSOLUTE ? 'absolute' : 'relative';\n    },\n    set: function set(value) {\n      this.layout.setPositionType(value === 'absolute' ? Yoga.POSITION_TYPE_ABSOLUTE : Yoga.POSITION_TYPE_RELATIVE);\n    }\n  }, {\n    key: \"top\",\n    get: function get() {\n      return this.layout.getComputedTop() || 0;\n    },\n    set: function set(value) {\n      this.setPosition(Yoga.EDGE_TOP, value);\n    }\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this.layout.getComputedLeft() || 0;\n    },\n    set: function set(value) {\n      this.setPosition(Yoga.EDGE_LEFT, value);\n    }\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this.layout.getComputedRight() || 0;\n    },\n    set: function set(value) {\n      this.setPosition(Yoga.EDGE_RIGHT, value);\n    }\n  }, {\n    key: \"bottom\",\n    get: function get() {\n      return this.layout.getComputedBottom() || 0;\n    },\n    set: function set(value) {\n      this.setPosition(Yoga.EDGE_BOTTOM, value);\n    }\n  }, {\n    key: \"width\",\n    get: function get() {\n      return this.layout.getComputedWidth();\n    },\n    set: function set(value) {\n      this.setDimension('width', value);\n    }\n  }, {\n    key: \"minWidth\",\n    get: function get() {\n      return this.layout.getMinWidth().value;\n    },\n    set: function set(value) {\n      this.setDimension('minWidth', value);\n    }\n  }, {\n    key: \"maxWidth\",\n    get: function get() {\n      return this.layout.getMaxWidth().value;\n    },\n    set: function set(value) {\n      this.setDimension('maxWidth', value);\n    }\n  }, {\n    key: \"height\",\n    get: function get() {\n      return this.layout.getComputedHeight();\n    },\n    set: function set(value) {\n      this.setDimension('height', value);\n    }\n  }, {\n    key: \"minHeight\",\n    get: function get() {\n      return this.layout.getMinHeight().value;\n    },\n    set: function set(value) {\n      this.setDimension('minHeight', value);\n    }\n  }, {\n    key: \"maxHeight\",\n    get: function get() {\n      return this.layout.getMaxHeight().value;\n    },\n    set: function set(value) {\n      this.setDimension('maxHeight', value);\n    }\n  }, {\n    key: \"paddingTop\",\n    get: function get() {\n      return this.layout.getComputedPadding(Yoga.EDGE_TOP) || 0;\n    },\n    set: function set(value) {\n      this.setPadding(Yoga.EDGE_TOP, value);\n    }\n  }, {\n    key: \"paddingRight\",\n    get: function get() {\n      return this.layout.getComputedPadding(Yoga.EDGE_RIGHT) || 0;\n    },\n    set: function set(value) {\n      this.setPadding(Yoga.EDGE_RIGHT, value);\n    }\n  }, {\n    key: \"paddingBottom\",\n    get: function get() {\n      return this.layout.getComputedPadding(Yoga.EDGE_BOTTOM) || 0;\n    },\n    set: function set(value) {\n      this.setPadding(Yoga.EDGE_BOTTOM, value);\n    }\n  }, {\n    key: \"paddingLeft\",\n    get: function get() {\n      return this.layout.getComputedPadding(Yoga.EDGE_LEFT) || 0;\n    },\n    set: function set(value) {\n      this.setPadding(Yoga.EDGE_LEFT, value);\n    }\n  }, {\n    key: \"marginTop\",\n    get: function get() {\n      return this.layout.getComputedMargin(Yoga.EDGE_TOP) || 0;\n    },\n    set: function set(value) {\n      this.setMargin(Yoga.EDGE_TOP, value);\n    }\n  }, {\n    key: \"marginRight\",\n    get: function get() {\n      return this.layout.getComputedMargin(Yoga.EDGE_RIGHT) || 0;\n    },\n    set: function set(value) {\n      this.setMargin(Yoga.EDGE_RIGHT, value);\n    }\n  }, {\n    key: \"marginBottom\",\n    get: function get() {\n      return this.layout.getComputedMargin(Yoga.EDGE_BOTTOM) || 0;\n    },\n    set: function set(value) {\n      this.setMargin(Yoga.EDGE_BOTTOM, value);\n    }\n  }, {\n    key: \"marginLeft\",\n    get: function get() {\n      return this.layout.getComputedMargin(Yoga.EDGE_LEFT) || 0;\n    },\n    set: function set(value) {\n      this.setMargin(Yoga.EDGE_LEFT, value);\n    }\n  }, {\n    key: \"borderTopWidth\",\n    get: function get() {\n      return this.layout.getComputedBorder(Yoga.EDGE_TOP) || 0;\n    },\n    set: function set(value) {\n      this.setBorder(Yoga.EDGE_TOP, value);\n    }\n  }, {\n    key: \"borderRightWidth\",\n    get: function get() {\n      return this.layout.getComputedBorder(Yoga.EDGE_RIGHT) || 0;\n    },\n    set: function set(value) {\n      this.setBorder(Yoga.EDGE_RIGHT, value);\n    }\n  }, {\n    key: \"borderBottomWidth\",\n    get: function get() {\n      return this.layout.getComputedBorder(Yoga.EDGE_BOTTOM) || 0;\n    },\n    set: function set(value) {\n      this.setBorder(Yoga.EDGE_BOTTOM, value);\n    }\n  }, {\n    key: \"borderLeftWidth\",\n    get: function get() {\n      return this.layout.getComputedBorder(Yoga.EDGE_LEFT) || 0;\n    },\n    set: function set(value) {\n      this.setBorder(Yoga.EDGE_LEFT, value);\n    }\n  }, {\n    key: \"padding\",\n    get: function get() {\n      return {\n        top: this.paddingTop,\n        right: this.paddingRight,\n        bottom: this.paddingBottom,\n        left: this.paddingLeft\n      };\n    },\n    set: function set(value) {\n      this.paddingTop = value;\n      this.paddingRight = value;\n      this.paddingBottom = value;\n      this.paddingLeft = value;\n    }\n  }, {\n    key: \"margin\",\n    get: function get() {\n      return {\n        top: this.marginTop,\n        right: this.marginRight,\n        bottom: this.marginBottom,\n        left: this.marginLeft\n      };\n    },\n    set: function set(value) {\n      this.marginTop = value;\n      this.marginRight = value;\n      this.marginBottom = value;\n      this.marginLeft = value;\n    }\n  }]);\n\n  return Node;\n}();\n\nvar yogaValue = function yogaValue(prop, value) {\n  var isAlignType = function isAlignType(prop) {\n    return prop === 'alignItems' || prop === 'alignContent' || prop === 'alignSelf';\n  };\n\n  switch (value) {\n    case 'auto':\n      if (prop === 'alignSelf') {\n        return Yoga.ALIGN_AUTO;\n      }\n\n      break;\n\n    case 'flex':\n      return Yoga.DISPLAY_FLEX;\n\n    case 'none':\n      return Yoga.DISPLAY_NONE;\n\n    case 'row':\n      return Yoga.FLEX_DIRECTION_ROW;\n\n    case 'row-reverse':\n      return Yoga.FLEX_DIRECTION_ROW_REVERSE;\n\n    case 'column':\n      return Yoga.FLEX_DIRECTION_COLUMN;\n\n    case 'column-reverse':\n      return Yoga.FLEX_DIRECTION_COLUMN_REVERSE;\n\n    case 'stretch':\n      return Yoga.ALIGN_STRETCH;\n\n    case 'baseline':\n      return Yoga.ALIGN_BASELINE;\n\n    case 'space-around':\n      if (prop === 'justifyContent') {\n        return Yoga.JUSTIFY_SPACE_AROUND;\n      } else if (isAlignType(prop)) {\n        return Yoga.ALIGN_SPACE_AROUND;\n      }\n\n      break;\n\n    case 'space-between':\n      if (prop === 'justifyContent') {\n        return Yoga.JUSTIFY_SPACE_BETWEEN;\n      } else if (isAlignType(prop)) {\n        return Yoga.ALIGN_SPACE_BETWEEN;\n      }\n\n      break;\n\n    case 'around':\n      return Yoga.JUSTIFY_SPACE_AROUND;\n\n    case 'between':\n      return Yoga.JUSTIFY_SPACE_BETWEEN;\n\n    case 'wrap':\n      return Yoga.WRAP_WRAP;\n\n    case 'wrap-reverse':\n      return Yoga.WRAP_WRAP_REVERSE;\n\n    case 'nowrap':\n      return Yoga.WRAP_NO_WRAP;\n\n    case 'flex-start':\n      if (prop === 'justifyContent') {\n        return Yoga.JUSTIFY_FLEX_START;\n      } else if (isAlignType(prop)) {\n        return Yoga.ALIGN_FLEX_START;\n      }\n\n      break;\n\n    case 'flex-end':\n      if (prop === 'justifyContent') {\n        return Yoga.JUSTIFY_FLEX_END;\n      } else if (isAlignType(prop)) {\n        return Yoga.ALIGN_FLEX_END;\n      }\n\n      break;\n\n    case 'center':\n      if (prop === 'justifyContent') {\n        return Yoga.JUSTIFY_CENTER;\n      } else if (isAlignType(prop)) {\n        return Yoga.ALIGN_CENTER;\n      }\n\n      break;\n\n    default:\n      return value;\n  }\n}; // These are not supported yet\n\n\nvar DPI = 72; // 72pt per inch.\n\nvar parseValue = function parseValue(value) {\n  var match = /^(-?\\d*\\.?\\d+)(in|mm|cm|pt|vh|vw)?$/g.exec(value);\n\n  if (match) {\n    return {\n      value: parseFloat(match[1], 10),\n      unit: match[2] || 'pt'\n    };\n  }\n\n  return {\n    value: value,\n    unit: undefined\n  };\n};\n\nvar parseScalar = function parseScalar(value, container) {\n  var scalar = parseValue(value);\n\n  switch (scalar.unit) {\n    case 'in':\n      return scalar.value * DPI;\n\n    case 'mm':\n      return scalar.value * (1 / 25.4) * DPI;\n\n    case 'cm':\n      return scalar.value * (1 / 2.54) * DPI;\n\n    case 'vh':\n      if (container.isAutoHeight) {\n        throw new Error('vh unit not supported in auto-height pages. Please specify page height if you want to use vh.');\n      }\n\n      return scalar.value * (container.height / 100);\n\n    case 'vw':\n      return scalar.value * (container.width / 100);\n\n    default:\n      return scalar.value;\n  }\n};\n\nvar isBorderStyle = function isBorderStyle(key, value) {\n  return key.match(/^border/) && typeof value === 'string';\n};\n\nvar matchBorderShorthand = function matchBorderShorthand(value) {\n  return value.match(/(\\d+(px|in|mm|cm|pt|vw|vh)?)\\s(\\S+)\\s(\\S+)/);\n}; // Transforms shorthand border values\n\n\nvar processBorders = function processBorders(key, value) {\n  var match = matchBorderShorthand(value);\n\n  if (match) {\n    if (key.match(/.Color/)) {\n      return match[4];\n    } else if (key.match(/.Style/)) {\n      return match[3];\n    } else if (key.match(/.Width/)) {\n      return match[1];\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n  }\n\n  return value;\n};\n\nvar isBoxModelStyle = function isBoxModelStyle(key, value) {\n  return key.match(/^(margin)|(padding)/) && typeof value === 'string';\n};\n\nvar matchBoxModel = function matchBoxModel(value) {\n  return value.match(/\\d+(px|in|mm|cm|pt|%|vw|vh)?/g);\n}; // Transforms shorthand margin and padding values\n\n\nvar processBoxModel = function processBoxModel(key, value) {\n  var match = matchBoxModel(value);\n\n  if (match) {\n    if (key.match(/.Top/)) {\n      return match[0];\n    } else if (key.match(/.Right/)) {\n      return match[1] || match[0];\n    } else if (key.match(/.Bottom/)) {\n      return match[2] || match[0];\n    } else if (key.match(/.Left/)) {\n      return match[3] || match[1] || match[0];\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n  }\n\n  return value;\n}; // https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Common_weight_name_mapping\n\n\nvar FONT_WEIGHTS = {\n  thin: 100,\n  hairline: 100,\n  ultralight: 200,\n  extralight: 200,\n  light: 300,\n  normal: 400,\n  medium: 500,\n  semibold: 600,\n  demibold: 600,\n  bold: 700,\n  ultrabold: 800,\n  extrabold: 800,\n  heavy: 900,\n  black: 900\n};\n\nvar isFontWeightStyle = function isFontWeightStyle(key) {\n  return key.match(/^fontWeight/);\n};\n\nvar processFontWeight = function processFontWeight(value) {\n  if (!value) return FONT_WEIGHTS.normal;\n  if (typeof value === 'number') return value;\n  return FONT_WEIGHTS[value.toLowerCase()];\n};\n\nvar isObjectPositionStyle = function isObjectPositionStyle(key, value) {\n  return key.match(/^objectPosition/) && typeof value === 'string';\n};\n\nvar matchObjectPosition = function matchObjectPosition(value) {\n  return value.match(/\\d+(px|in|mm|cm|pt|%|vw|vh)?/g);\n}; // Transforms shorthand objectPosition values\n\n\nvar processObjectPosition = function processObjectPosition(key, value) {\n  var match = matchObjectPosition(value);\n\n  if (match) {\n    if (key.match(/.X/)) {\n      return match[0];\n    } else if (key.match(/.Y/)) {\n      return match[1];\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n  }\n\n  return value;\n};\n\nvar isTransformOriginStyle = function isTransformOriginStyle(key, value) {\n  return key.match(/^transformOrigin/) && typeof value === 'string';\n};\n\nvar matchTransformOrigin = function matchTransformOrigin(value) {\n  return value.match(/(-?\\d+(px|in|mm|cm|pt|%|vw|vh)?)|top|right|bottom|left|center/g);\n};\n\nvar transformOffsetKeywords = function transformOffsetKeywords(value) {\n  switch (value) {\n    case 'top':\n    case 'left':\n      return '0%';\n\n    case 'right':\n    case 'bottom':\n      return '100%';\n\n    case 'center':\n      return '50%';\n\n    default:\n      return value;\n  }\n}; // Transforms shorthand transformOrigin values\n\n\nvar processTransformOrigin = function processTransformOrigin(key, value) {\n  var match = matchTransformOrigin(value);\n\n  if (match) {\n    var result;\n\n    if (key.match(/.X/)) {\n      result = match[0];\n    } else if (key.match(/.Y/)) {\n      result = match[1] || match[0];\n    } else {\n      throw new Error(\"StyleSheet: Invalid '\" + value + \"' for '\" + key + \"'\");\n    }\n\n    return transformOffsetKeywords(result);\n  }\n\n  return value;\n};\n\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar styleShorthands = {\n  margin: {\n    marginTop: true,\n    marginRight: true,\n    marginBottom: true,\n    marginLeft: true\n  },\n  marginHorizontal: {\n    marginLeft: true,\n    marginRight: true\n  },\n  marginVertical: {\n    marginTop: true,\n    marginBottom: true\n  },\n  padding: {\n    paddingTop: true,\n    paddingRight: true,\n    paddingBottom: true,\n    paddingLeft: true\n  },\n  paddingHorizontal: {\n    paddingLeft: true,\n    paddingRight: true\n  },\n  paddingVertical: {\n    paddingTop: true,\n    paddingBottom: true\n  },\n  border: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true,\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true,\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true,\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true\n  },\n  borderTop: {\n    borderTopColor: true,\n    borderTopStyle: true,\n    borderTopWidth: true\n  },\n  borderRight: {\n    borderRightColor: true,\n    borderRightStyle: true,\n    borderRightWidth: true\n  },\n  borderBottom: {\n    borderBottomColor: true,\n    borderBottomStyle: true,\n    borderBottomWidth: true\n  },\n  borderLeft: {\n    borderLeftColor: true,\n    borderLeftStyle: true,\n    borderLeftWidth: true\n  },\n  borderColor: {\n    borderTopColor: true,\n    borderRightColor: true,\n    borderBottomColor: true,\n    borderLeftColor: true\n  },\n  borderRadius: {\n    borderTopLeftRadius: true,\n    borderTopRightRadius: true,\n    borderBottomRightRadius: true,\n    borderBottomLeftRadius: true\n  },\n  borderStyle: {\n    borderTopStyle: true,\n    borderRightStyle: true,\n    borderBottomStyle: true,\n    borderLeftStyle: true\n  },\n  borderWidth: {\n    borderTopWidth: true,\n    borderRightWidth: true,\n    borderBottomWidth: true,\n    borderLeftWidth: true\n  },\n  objectPosition: {\n    objectPositionX: true,\n    objectPositionY: true\n  },\n  transformOrigin: {\n    transformOriginX: true,\n    transformOriginY: true\n  }\n}; // Expand the shorthand properties to isolate every declaration from the others.\n\nvar expandStyles = function expandStyles(style) {\n  if (!style) return style;\n  var propsArray = Object.keys(style);\n  var resolvedStyle = {};\n\n  for (var i = 0; i < propsArray.length; i++) {\n    var key = propsArray[i];\n    var value = style[key];\n\n    switch (key) {\n      case 'display':\n      case 'flex':\n      case 'flexDirection':\n      case 'flexWrap':\n      case 'flexFlow':\n      case 'flexGrow':\n      case 'flexShrink':\n      case 'flexBasis':\n      case 'justifyContent':\n      case 'alignSelf':\n      case 'alignItems':\n      case 'alignContent':\n      case 'order':\n        resolvedStyle[key] = yogaValue(key, value);\n        break;\n\n      case 'textAlignVertical':\n        resolvedStyle.verticalAlign = value === 'center' ? 'middle' : value;\n        break;\n\n      case 'margin':\n      case 'marginHorizontal':\n      case 'marginVertical':\n      case 'padding':\n      case 'paddingHorizontal':\n      case 'paddingVertical':\n      case 'border':\n      case 'borderTop':\n      case 'borderRight':\n      case 'borderBottom':\n      case 'borderLeft':\n      case 'borderColor':\n      case 'borderRadius':\n      case 'borderStyle':\n      case 'borderWidth':\n      case 'objectPosition':\n      case 'transformOrigin':\n        {\n          var expandedProps = styleShorthands[key];\n\n          for (var propName in expandedProps) {\n            if (hasOwnProperty.call(expandedProps, propName)) {\n              resolvedStyle[propName] = value;\n            }\n          }\n        }\n        break;\n\n      default:\n        resolvedStyle[key] = value;\n        break;\n    }\n  }\n\n  return resolvedStyle;\n};\n\nvar transformStyles = function transformStyles(style, container) {\n  var expandedStyles = expandStyles(style);\n  var propsArray = Object.keys(expandedStyles);\n  var resolvedStyle = {};\n\n  for (var i = 0; i < propsArray.length; i++) {\n    var key = propsArray[i];\n    var value = expandedStyles[key];\n    var resolved = void 0;\n\n    if (isBorderStyle(key, value)) {\n      resolved = processBorders(key, value);\n    } else if (isBoxModelStyle(key, value)) {\n      resolved = processBoxModel(key, value);\n    } else if (isObjectPositionStyle(key, value)) {\n      resolved = processObjectPosition(key, value);\n    } else if (isTransformOriginStyle(key, value)) {\n      resolved = processTransformOrigin(key, value);\n    } else if (isFontWeightStyle(key)) {\n      resolved = processFontWeight(value);\n    } else {\n      resolved = value;\n    }\n\n    resolvedStyle[key] = parseScalar(resolved, container);\n  }\n\n  return resolvedStyle;\n};\n\nvar create = function create(styles) {\n  return styles;\n};\n\nvar flatten = function flatten(input) {\n  if (!Array.isArray(input)) {\n    input = [input];\n  }\n\n  var result = input.reduce(function (acc, style) {\n    if (style) {\n      var s = Array.isArray(style) ? flatten(style) : style;\n      Object.keys(s).forEach(function (key) {\n        if (s[key] !== null && s[key] !== undefined) {\n          acc[key] = s[key];\n        }\n      });\n    }\n\n    return acc;\n  }, {});\n  return result;\n};\n\nvar resolveMediaQueries = function resolveMediaQueries(input, container) {\n  var result = Object.keys(input).reduce(function (acc, key) {\n    var _extends2;\n\n    if (/@media/.test(key)) {\n      var _matchMedia;\n\n      return _extends({}, acc, {}, matchMedia((_matchMedia = {}, _matchMedia[key] = input[key], _matchMedia), container));\n    }\n\n    return _extends({}, acc, (_extends2 = {}, _extends2[key] = input[key], _extends2));\n  }, {});\n  return result;\n};\n\nvar resolve = function resolve(styles, container) {\n  if (!styles) return null;\n  styles = flatten(styles);\n  styles = resolveMediaQueries(styles, container);\n  styles = transformStyles(styles, container);\n  return styles;\n};\n\nvar absoluteFillObject = {\n  position: 'absolute',\n  top: 0,\n  left: 0,\n  bottom: 0,\n  right: 0\n};\nvar StyleSheet = {\n  hairlineWidth: 1,\n  create: create,\n  resolve: resolve,\n  flatten: flatten,\n  absoluteFillObject: absoluteFillObject\n};\nvar Debug = {\n  debug: function debug() {\n    var layout = this.getAbsoluteLayout();\n    var padding = this.padding;\n    var margin = this.margin;\n    this.root.instance.save();\n    this.debugContent(layout, margin, padding);\n    this.debugPadding(layout, margin, padding);\n    this.debugMargin(layout, margin);\n    this.debugText(layout, margin);\n    this.debugOrigin();\n    this.root.instance.restore();\n  },\n  debugOrigin: function debugOrigin() {\n    if (this.style.transform) {\n      var origin = this.origin;\n      this.root.instance.circle(origin[0], origin[1], 3).fill('red').circle(origin[0], origin[1], 5).stroke('red');\n    }\n  },\n  debugText: function debugText(layout, margin) {\n    var roundedWidth = Math.round(this.width + margin.left + margin.right);\n    var roundedHeight = Math.round(this.height + margin.top + margin.bottom);\n    this.root.instance.fontSize(4).opacity(1).fillColor('black').text(roundedWidth + \" x \" + roundedHeight, layout.left - margin.left, Math.max(layout.top - margin.top - 4, 1));\n  },\n  debugContent: function debugContent(layout, margin, padding) {\n    this.root.instance.fillColor('#a1c6e7').opacity(0.5).rect(layout.left + padding.left, layout.top + padding.top, layout.width - padding.left - padding.right, layout.height - padding.top - padding.bottom).fill();\n  },\n  debugPadding: function debugPadding(layout, margin, padding) {\n    this.root.instance.fillColor('#c4deb9').opacity(0.5); // Padding top\n\n    this.root.instance.rect(layout.left + padding.left, layout.top, layout.width - padding.right - padding.left, padding.top).fill(); // Padding left\n\n    this.root.instance.rect(layout.left, layout.top, padding.left, layout.height).fill(); // Padding right\n\n    this.root.instance.rect(layout.left + layout.width - padding.right, layout.top, padding.right, layout.height).fill(); // Padding bottom\n\n    this.root.instance.rect(layout.left + padding.left, layout.top + layout.height - padding.bottom, layout.width - padding.right - padding.left, padding.bottom).fill();\n  },\n  debugMargin: function debugMargin(layout, margin) {\n    this.root.instance.fillColor('#f8cca1').opacity(0.5); // Margin top\n\n    this.root.instance.rect(layout.left, layout.top - margin.top, layout.width, margin.top).fill(); // Margin left\n\n    this.root.instance.rect(layout.left - margin.left, layout.top - margin.top, margin.left, layout.height + margin.top + margin.bottom).fill(); // Margin right\n\n    this.root.instance.rect(layout.left + layout.width, layout.top - margin.top, margin.right, layout.height + margin.top + margin.bottom).fill(); // Margin bottom\n\n    this.root.instance.rect(layout.left, layout.top + layout.height, layout.width, margin.bottom).fill();\n  }\n}; // Ref: https://www.w3.org/TR/css-backgrounds-3/#borders\n// This constant is used to approximate a symmetrical arc using a cubic Bezier curve.\n\nvar KAPPA = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\n\nfunction drawBorders() {\n  var instance = this.root.instance;\n  var layout = this.getAbsoluteLayout();\n  var borderTopWidth = this.borderTopWidth,\n      borderLeftWidth = this.borderLeftWidth,\n      borderRightWidth = this.borderRightWidth,\n      borderBottomWidth = this.borderBottomWidth;\n  var _this$style = this.style,\n      opacity = _this$style.opacity,\n      _this$style$borderTop = _this$style.borderTopLeftRadius,\n      borderTopLeftRadius = _this$style$borderTop === void 0 ? 0 : _this$style$borderTop,\n      _this$style$borderTop2 = _this$style.borderTopRightRadius,\n      borderTopRightRadius = _this$style$borderTop2 === void 0 ? 0 : _this$style$borderTop2,\n      _this$style$borderBot = _this$style.borderBottomLeftRadius,\n      borderBottomLeftRadius = _this$style$borderBot === void 0 ? 0 : _this$style$borderBot,\n      _this$style$borderBot2 = _this$style.borderBottomRightRadius,\n      borderBottomRightRadius = _this$style$borderBot2 === void 0 ? 0 : _this$style$borderBot2,\n      _this$style$borderTop3 = _this$style.borderTopColor,\n      borderTopColor = _this$style$borderTop3 === void 0 ? 'black' : _this$style$borderTop3,\n      _this$style$borderTop4 = _this$style.borderTopStyle,\n      borderTopStyle = _this$style$borderTop4 === void 0 ? 'solid' : _this$style$borderTop4,\n      _this$style$borderLef = _this$style.borderLeftColor,\n      borderLeftColor = _this$style$borderLef === void 0 ? 'black' : _this$style$borderLef,\n      _this$style$borderLef2 = _this$style.borderLeftStyle,\n      borderLeftStyle = _this$style$borderLef2 === void 0 ? 'solid' : _this$style$borderLef2,\n      _this$style$borderRig = _this$style.borderRightColor,\n      borderRightColor = _this$style$borderRig === void 0 ? 'black' : _this$style$borderRig,\n      _this$style$borderRig2 = _this$style.borderRightStyle,\n      borderRightStyle = _this$style$borderRig2 === void 0 ? 'solid' : _this$style$borderRig2,\n      _this$style$borderBot3 = _this$style.borderBottomColor,\n      borderBottomColor = _this$style$borderBot3 === void 0 ? 'black' : _this$style$borderBot3,\n      _this$style$borderBot4 = _this$style.borderBottomStyle,\n      borderBottomStyle = _this$style$borderBot4 === void 0 ? 'solid' : _this$style$borderBot4;\n  var style = {\n    borderTopColor: borderTopColor,\n    borderTopWidth: borderTopWidth,\n    borderTopStyle: borderTopStyle,\n    borderLeftColor: borderLeftColor,\n    borderLeftWidth: borderLeftWidth,\n    borderLeftStyle: borderLeftStyle,\n    borderRightColor: borderRightColor,\n    borderRightWidth: borderRightWidth,\n    borderRightStyle: borderRightStyle,\n    borderBottomColor: borderBottomColor,\n    borderBottomWidth: borderBottomWidth,\n    borderBottomStyle: borderBottomStyle,\n    borderTopLeftRadius: borderTopLeftRadius,\n    borderTopRightRadius: borderTopRightRadius,\n    borderBottomLeftRadius: borderBottomLeftRadius,\n    borderBottomRightRadius: borderBottomRightRadius\n  };\n  var width = layout.width,\n      height = layout.height;\n  var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n  var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n  var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n  var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n  instance.save();\n  instance.strokeOpacity(opacity);\n\n  if (borderTopWidth) {\n    instance.save();\n    clipBorderTop(instance, layout, style, rtr, rtl);\n    fillBorderTop(instance, layout, style, rtr, rtl);\n    instance.restore();\n  }\n\n  if (borderRightWidth) {\n    instance.save();\n    clipBorderRight(instance, layout, style, rtr, rbr);\n    fillBorderRight(instance, layout, style, rtr, rbr);\n    instance.restore();\n  }\n\n  if (borderBottomWidth) {\n    instance.save();\n    clipBorderBottom(instance, layout, style, rbl, rbr);\n    fillBorderBottom(instance, layout, style, rbl, rbr);\n    instance.restore();\n  }\n\n  if (borderLeftWidth) {\n    instance.save();\n    clipBorderLeft(instance, layout, style, rbl, rtl);\n    fillBorderLeft(instance, layout, style, rbl, rtl);\n    instance.restore();\n  }\n\n  instance.restore();\n}\n\nvar clipBorderTop = function clipBorderTop(ctx, layout, style, rtr, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth; // Clip outer top border edge\n\n  ctx.moveTo(left + rtl, top);\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  var c0 = rtr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c0, top, left + width, top + c0, left + width, top + rtr); // Move down in case the margin exceedes the radius\n\n  var topRightYCoord = top + Math.max(borderTopWidth, rtr);\n  ctx.lineTo(left + width, topRightYCoord); // Clip inner top right cap\n\n  ctx.lineTo(left + width - borderRightWidth, topRightYCoord); // Ellipse coefficients inner top right cap\n\n  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  var c1 = innerTopRightRadiusX * (1.0 - KAPPA);\n  var c2 = innerTopRightRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c2, left + width - borderRightWidth - c1, top + borderTopWidth, left + width - borderRightWidth - innerTopRightRadiusX, top + borderTopWidth); // Clip inner top border edge\n\n  ctx.lineTo(left + Math.max(rtl, borderLeftWidth), top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  var c3 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  var c4 = innerTopLeftRadiusY * (1.0 - KAPPA);\n  var topLeftYCoord = top + Math.max(borderTopWidth, rtl); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c3, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c4, left + borderLeftWidth, topLeftYCoord);\n  ctx.lineTo(left, topLeftYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  var c5 = rtl * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c5, left + c5, top, left + rtl, top);\n  ctx.closePath();\n  ctx.clip(); // Clip border top cap joins\n\n  if (borderRightWidth) {\n    var trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    var _trSlope = -borderTopWidth / borderLeftWidth;\n\n    ctx.moveTo(left + width / 2, _trSlope * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderTop = function fillBorderTop(ctx, layout, style, rtr, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width;\n  var borderTopColor = style.borderTopColor,\n      borderTopWidth = style.borderTopWidth,\n      borderTopStyle = style.borderTopStyle,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth;\n  var c0 = rtl * (1.0 - KAPPA);\n  var c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left, top + Math.max(rtl, borderTopWidth));\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top);\n  ctx.lineTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.strokeColor(borderTopColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderLeftWidth) * 2);\n\n  if (borderTopStyle === 'dashed') {\n    ctx.dash(borderTopWidth * 2, {\n      space: borderTopWidth * 1.2\n    });\n  } else if (borderTopStyle === 'dotted') {\n    ctx.dash(borderTopWidth, {\n      space: borderTopWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar clipBorderRight = function clipBorderRight(ctx, layout, style, rtr, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderBottomWidth = style.borderBottomWidth; // Clip outer right border edge\n\n  ctx.moveTo(left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer bottom right cap\n\n  var c0 = rbr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height); // Move left in case the margin exceedes the radius\n\n  var topBottomXCoord = left + width - Math.max(borderRightWidth, rbr);\n  ctx.lineTo(topBottomXCoord, top + height); // Clip inner bottom right cap\n\n  ctx.lineTo(topBottomXCoord, top + height - borderBottomWidth); // Ellipse coefficients inner bottom right cap\n\n  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  var c1 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  var c2 = innerBottomRightRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c1, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c2, left + width - borderRightWidth, top + height - Math.max(rbr, borderBottomWidth)); // Clip inner right border edge\n\n  ctx.lineTo(left + width - borderRightWidth, top + Math.max(rtr, borderTopWidth)); // Ellipse coefficients inner top right cap\n\n  var innerTopRightRadiusX = Math.max(rtr - borderRightWidth, 0);\n  var innerTopRightRadiusY = Math.max(rtr - borderTopWidth, 0);\n  var c3 = innerTopRightRadiusX * (1.0 - KAPPA);\n  var c4 = innerTopRightRadiusY * (1.0 - KAPPA);\n  var topRightXCoord = left + width - Math.max(rtr, borderRightWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth, top + borderTopWidth + c4, left + width - borderRightWidth - c3, top + borderTopWidth, topRightXCoord, top + borderTopWidth);\n  ctx.lineTo(topRightXCoord, top); // Move right in case the margin exceedes the radius\n\n  ctx.lineTo(left + width - rtr, top); // Ellipse coefficients outer top right cap\n\n  var c5 = rtr * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + width - c5, top, left + width, top + c5, left + width, top + rtr);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderTopWidth) {\n    var trSlope = -borderTopWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, trSlope * (-width / 2) + top);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    var brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderRight = function fillBorderRight(ctx, layout, style, rtr, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderRightColor = style.borderRightColor,\n      borderRightStyle = style.borderRightStyle,\n      borderRightWidth = style.borderRightWidth,\n      borderTopWidth = style.borderTopWidth,\n      borderBottomWidth = style.borderBottomWidth;\n  var c0 = rbr * (1.0 - KAPPA);\n  var c1 = rtr * (1.0 - KAPPA);\n  ctx.moveTo(left + width - rtr, top);\n  ctx.bezierCurveTo(left + width - c1, top, left + width, top + c1, left + width, top + rtr);\n  ctx.lineTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c0, left + width - c0, top + height, left + width - rbr, top + height);\n  ctx.strokeColor(borderRightColor);\n  ctx.lineWidth(Math.max(borderRightWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderRightStyle === 'dashed') {\n    ctx.dash(borderRightWidth * 2, {\n      space: borderRightWidth * 1.2\n    });\n  } else if (borderRightStyle === 'dotted') {\n    ctx.dash(borderRightWidth, {\n      space: borderRightWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar clipBorderBottom = function clipBorderBottom(ctx, layout, style, rbl, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderBottomWidth = style.borderBottomWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth; // Clip outer top border edge\n\n  ctx.moveTo(left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  var c0 = rbl * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl); // Move up in case the margin exceedes the radius\n\n  var bottomLeftYCoord = top + height - Math.max(borderBottomWidth, rbl);\n  ctx.lineTo(left, bottomLeftYCoord); // Clip inner bottom left cap\n\n  ctx.lineTo(left + borderLeftWidth, bottomLeftYCoord); // Ellipse coefficients inner top right cap\n\n  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  var c1 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  var c2 = innerBottomLeftRadiusY * (1.0 - KAPPA); // Clip inner bottom left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c2, left + borderLeftWidth + c1, top + height - borderBottomWidth, left + borderLeftWidth + innerBottomLeftRadiusX, top + height - borderBottomWidth); // Clip inner bottom border edge\n\n  ctx.lineTo(left + width - Math.max(rbr, borderRightWidth), top + height - borderBottomWidth); // Ellipse coefficients inner top left cap\n\n  var innerBottomRightRadiusX = Math.max(rbr - borderRightWidth, 0);\n  var innerBottomRightRadiusY = Math.max(rbr - borderBottomWidth, 0);\n  var c3 = innerBottomRightRadiusX * (1.0 - KAPPA);\n  var c4 = innerBottomRightRadiusY * (1.0 - KAPPA);\n  var bottomRightYCoord = top + height - Math.max(borderBottomWidth, rbr); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + width - borderRightWidth - c3, top + height - borderBottomWidth, left + width - borderRightWidth, top + height - borderBottomWidth - c4, left + width - borderRightWidth, bottomRightYCoord);\n  ctx.lineTo(left + width, bottomRightYCoord); // Move down in case the margin exceedes the radius\n\n  ctx.lineTo(left + width, top + height - rbr); // Ellipse coefficients outer top left cap\n\n  var c5 = rbr * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left + width, top + height - c5, left + width - c5, top + height, left + width - rbr, top + height);\n  ctx.closePath();\n  ctx.clip(); // Clip border bottom cap joins\n\n  if (borderRightWidth) {\n    var brSlope = borderBottomWidth / borderRightWidth;\n    ctx.moveTo(left + width / 2, brSlope * (-width / 2) + top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderLeftWidth) {\n    var trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderBottom = function fillBorderBottom(ctx, layout, style, rbl, rbr) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderBottomColor = style.borderBottomColor,\n      borderBottomStyle = style.borderBottomStyle,\n      borderBottomWidth = style.borderBottomWidth,\n      borderRightWidth = style.borderRightWidth,\n      borderLeftWidth = style.borderLeftWidth;\n  var c0 = rbl * (1.0 - KAPPA);\n  var c1 = rbr * (1.0 - KAPPA);\n  ctx.moveTo(left + width, top + height - rbr);\n  ctx.bezierCurveTo(left + width, top + height - c1, left + width - c1, top + height, left + width - rbr, top + height);\n  ctx.lineTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.strokeColor(borderBottomColor);\n  ctx.lineWidth(Math.max(borderBottomWidth, borderRightWidth, borderLeftWidth) * 2);\n\n  if (borderBottomStyle === 'dashed') {\n    ctx.dash(borderBottomWidth * 2, {\n      space: borderBottomWidth * 1.2\n    });\n  } else if (borderBottomStyle === 'dotted') {\n    ctx.dash(borderBottomWidth, {\n      space: borderBottomWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar clipBorderLeft = function clipBorderLeft(ctx, layout, style, rbl, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      width = layout.width,\n      height = layout.height;\n  var borderTopWidth = style.borderTopWidth,\n      borderLeftWidth = style.borderLeftWidth,\n      borderBottomWidth = style.borderBottomWidth; // Clip outer left border edge\n\n  ctx.moveTo(left, top + height - rbl);\n  ctx.lineTo(left, top + rtl); // Ellipse coefficients outer top left cap\n\n  var c0 = rtl * (1.0 - KAPPA); // Clip outer top left cap\n\n  ctx.bezierCurveTo(left, top + c0, left + c0, top, left + rtl, top); // Move right in case the margin exceedes the radius\n\n  var topLeftCoordX = left + Math.max(borderLeftWidth, rtl);\n  ctx.lineTo(topLeftCoordX, top); // Clip inner top left cap\n\n  ctx.lineTo(topLeftCoordX, top + borderTopWidth); // Ellipse coefficients inner top left cap\n\n  var innerTopLeftRadiusX = Math.max(rtl - borderLeftWidth, 0);\n  var innerTopLeftRadiusY = Math.max(rtl - borderTopWidth, 0);\n  var c1 = innerTopLeftRadiusX * (1.0 - KAPPA);\n  var c2 = innerTopLeftRadiusY * (1.0 - KAPPA); // Clip inner top right cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth + c1, top + borderTopWidth, left + borderLeftWidth, top + borderTopWidth + c2, left + borderLeftWidth, top + Math.max(rtl, borderTopWidth)); // Clip inner left border edge\n\n  ctx.lineTo(left + borderLeftWidth, top + height - Math.max(rbl, borderBottomWidth)); // Ellipse coefficients inner bottom left cap\n\n  var innerBottomLeftRadiusX = Math.max(rbl - borderLeftWidth, 0);\n  var innerBottomLeftRadiusY = Math.max(rbl - borderBottomWidth, 0);\n  var c3 = innerBottomLeftRadiusX * (1.0 - KAPPA);\n  var c4 = innerBottomLeftRadiusY * (1.0 - KAPPA);\n  var bottomLeftXCoord = left + Math.max(rbl, borderLeftWidth); // Clip inner top left cap\n\n  ctx.bezierCurveTo(left + borderLeftWidth, top + height - borderBottomWidth - c4, left + borderLeftWidth + c3, top + height - borderBottomWidth, bottomLeftXCoord, top + height - borderBottomWidth);\n  ctx.lineTo(bottomLeftXCoord, top + height); // Move left in case the margin exceedes the radius\n\n  ctx.lineTo(left + rbl, top + height); // Ellipse coefficients outer top right cap\n\n  var c5 = rbl * (1.0 - KAPPA); // Clip outer top right cap\n\n  ctx.bezierCurveTo(left + c5, top + height, left, top + height - c5, left, top + height - rbl);\n  ctx.closePath();\n  ctx.clip(); // Clip border right cap joins\n\n  if (borderBottomWidth) {\n    var trSlope = -borderBottomWidth / borderLeftWidth;\n    ctx.moveTo(left + width / 2, trSlope * (width / 2) + top + height);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left + width, top);\n    ctx.closePath();\n    ctx.clip();\n  }\n\n  if (borderBottomWidth) {\n    var _trSlope2 = -borderTopWidth / borderLeftWidth;\n\n    ctx.moveTo(left + width / 2, _trSlope2 * (-width / 2) + top);\n    ctx.lineTo(left, top);\n    ctx.lineTo(left, top + height);\n    ctx.lineTo(left + width, top + height);\n    ctx.closePath();\n    ctx.clip();\n  }\n};\n\nvar fillBorderLeft = function fillBorderLeft(ctx, layout, style, rbl, rtl) {\n  var top = layout.top,\n      left = layout.left,\n      height = layout.height;\n  var borderLeftColor = style.borderLeftColor,\n      borderLeftStyle = style.borderLeftStyle,\n      borderLeftWidth = style.borderLeftWidth,\n      borderTopWidth = style.borderTopWidth,\n      borderBottomWidth = style.borderBottomWidth;\n  var c0 = rbl * (1.0 - KAPPA);\n  var c1 = rtl * (1.0 - KAPPA);\n  ctx.moveTo(left + rbl, top + height);\n  ctx.bezierCurveTo(left + c0, top + height, left, top + height - c0, left, top + height - rbl);\n  ctx.lineTo(left, top + rtl);\n  ctx.bezierCurveTo(left, top + c1, left + c1, top, left + rtl, top);\n  ctx.strokeColor(borderLeftColor);\n  ctx.lineWidth(Math.max(borderLeftWidth, borderTopWidth, borderBottomWidth) * 2);\n\n  if (borderLeftStyle === 'dashed') {\n    ctx.dash(borderLeftWidth * 2, {\n      space: borderLeftWidth * 1.2\n    });\n  } else if (borderLeftStyle === 'dotted') {\n    ctx.dash(borderLeftWidth, {\n      space: borderLeftWidth * 1.2\n    });\n  }\n\n  ctx.stroke();\n  ctx.undash();\n};\n\nvar Borders = {\n  drawBorders: drawBorders\n}; // This constant is used to approximate a symmetrical arc using a cubic\n// Bezier curve.\n\nvar KAPPA$1 = 4.0 * ((Math.sqrt(2) - 1.0) / 3.0);\nvar Clipping = {\n  clip: function clip() {\n    var _this$getAbsoluteLayo = this.getAbsoluteLayout(),\n        top = _this$getAbsoluteLayo.top,\n        left = _this$getAbsoluteLayo.left,\n        width = _this$getAbsoluteLayo.width,\n        height = _this$getAbsoluteLayo.height;\n\n    var _this$style = this.style,\n        _this$style$borderTop = _this$style.borderTopLeftRadius,\n        borderTopLeftRadius = _this$style$borderTop === void 0 ? 0 : _this$style$borderTop,\n        _this$style$borderTop2 = _this$style.borderTopRightRadius,\n        borderTopRightRadius = _this$style$borderTop2 === void 0 ? 0 : _this$style$borderTop2,\n        _this$style$borderBot = _this$style.borderBottomRightRadius,\n        borderBottomRightRadius = _this$style$borderBot === void 0 ? 0 : _this$style$borderBot,\n        _this$style$borderBot2 = _this$style.borderBottomLeftRadius,\n        borderBottomLeftRadius = _this$style$borderBot2 === void 0 ? 0 : _this$style$borderBot2; // Border top\n\n    var rtr = Math.min(borderTopRightRadius, 0.5 * width, 0.5 * height);\n    var ctr = rtr * (1.0 - KAPPA$1);\n    this.root.instance.moveTo(left + rtr, top);\n    this.root.instance.lineTo(left + width - rtr, top);\n    this.root.instance.bezierCurveTo(left + width - ctr, top, left + width, top + ctr, left + width, top + rtr); // Border right\n\n    var rbr = Math.min(borderBottomRightRadius, 0.5 * width, 0.5 * height);\n    var cbr = rbr * (1.0 - KAPPA$1);\n    this.root.instance.lineTo(left + width, top + height - rbr);\n    this.root.instance.bezierCurveTo(left + width, top + height - cbr, left + width - cbr, top + height, left + width - rbr, top + height); // Border bottom\n\n    var rbl = Math.min(borderBottomLeftRadius, 0.5 * width, 0.5 * height);\n    var cbl = rbl * (1.0 - KAPPA$1);\n    this.root.instance.lineTo(left + rbl, top + height);\n    this.root.instance.bezierCurveTo(left + cbl, top + height, left, top + height - cbl, left, top + height - rbl); // Border left\n\n    var rtl = Math.min(borderTopLeftRadius, 0.5 * width, 0.5 * height);\n    var ctl = rtl * (1.0 - KAPPA$1);\n    this.root.instance.lineTo(left, top + rtl);\n    this.root.instance.bezierCurveTo(left, top + ctl, left + ctl, top, left + rtl, top);\n    this.root.instance.closePath();\n    this.root.instance.clip();\n  }\n};\n\nvar getRotation = function getRotation(transform) {\n  var match = /rotate\\((-?\\d+.?\\d+)(.+)\\)/g.exec(transform);\n\n  if (match && match[1] && match[2]) {\n    var value = match[1];\n    return match[2] === 'rad' ? value * 180 / Math.PI : value;\n  }\n\n  return 0;\n};\n\nvar getTranslateX = function getTranslateX(transform) {\n  var matchX = /translateX\\((-?\\d+\\.?d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?d*).*,\\s*(-?\\d+\\.?d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 0;\n};\n\nvar getTranslateY = function getTranslateY(transform) {\n  var matchY = /translateY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /translate\\((-?\\d+\\.?\\d*).*,\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n  return 0;\n};\n\nvar getScaleX = function getScaleX(transform) {\n  var matchX = /scaleX\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchX && matchX[1]) return matchX[1];\n  if (matchGeneric && matchGeneric[1]) return matchGeneric[1];\n  return 1;\n};\n\nvar getScaleY = function getScaleY(transform) {\n  var matchY = /scaleY\\((-?\\d+\\.?\\d*)\\)/g.exec(transform);\n  var matchGeneric = /scale\\((-?\\d+\\.?\\d*).*,\\s*(-?\\d+\\.?\\d*).*\\)/g.exec(transform);\n  if (matchY && matchY[1]) return matchY[1];\n  if (matchGeneric && matchGeneric[2]) return matchGeneric[2];\n  return 1;\n};\n\nvar getMatrix = function getMatrix(transform) {\n  var match = /matrix\\(([^,]+),([^,]+),([^,]+),([^,]+),([^,]+),([^,]+)\\)/g.exec(transform);\n  if (match) return match.slice(1, 7);\n  return null;\n};\n\nvar applySingleTransformation = function applySingleTransformation(element, transform, origin) {\n  if (/rotate/g.test(transform)) {\n    element.root.instance.rotate(getRotation(transform), {\n      origin: origin\n    });\n  } else if (/scaleX/g.test(transform)) {\n    element.root.instance.scale(getScaleX(transform), 1, {\n      origin: origin\n    });\n  } else if (/scaleY/g.test(transform)) {\n    element.root.instance.scale(1, getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/scale/g.test(transform)) {\n    element.root.instance.scale(getScaleX(transform), getScaleY(transform), {\n      origin: origin\n    });\n  } else if (/translateX/g.test(transform)) {\n    element.root.instance.translate(getTranslateX(transform), 1, {\n      origin: origin\n    });\n  } else if (/translateY/g.test(transform)) {\n    element.root.instance.translate(1, getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/translate/g.test(transform)) {\n    element.root.instance.translate(getTranslateX(transform), getTranslateY(transform), {\n      origin: origin\n    });\n  } else if (/matrix/g.test(transform)) {\n    var _element$root$instanc;\n\n    (_element$root$instanc = element.root.instance).transform.apply(_element$root$instanc, getMatrix(transform));\n  }\n};\n\nvar Transformations = {\n  applyTransformations: function applyTransformations() {\n    var match;\n    var re = /[a-zA-Z]+\\([^)]+\\)/g;\n    var origin = this.origin;\n    var transform = this.style && this.style.transform || '';\n\n    while ((match = re.exec(transform)) != null) {\n      applySingleTransformation(this, match[0], origin);\n    }\n  }\n};\n\nvar merge = function merge(a, b) {\n  return isNil(b) ? a : b;\n};\n\nvar deepMerge = function deepMerge(objs) {\n  return objs.reduce(function (acc, obj) {\n    return mergeDeepWith(merge, acc, obj);\n  }, {});\n};\n\nvar isFunction = compose(equals('Function'), type);\nvar inheritedProperties = ['color', 'fontFamily', 'fontSize', 'fontStyle', 'fontWeight', 'letterSpacing', 'opacity', 'textDecoration', 'lineHeight', 'textAlign', 'visibility', 'wordSpacing'];\n\nvar Base =\n/*#__PURE__*/\nfunction (_Node) {\n  _inheritsLoose(Base, _Node);\n\n  function Base(root, props) {\n    var _this;\n\n    _this = _Node.call(this) || this;\n    _this.root = root;\n    _this.style = {};\n    _this.props = deepMerge([_this.constructor.defaultProps, Base.defaultProps, props]);\n    warning(!_this.props.styles, '\"styles\" prop passed instead of \"style\" prop');\n    return _this;\n  }\n\n  var _proto = Base.prototype;\n\n  _proto.appendChild = function appendChild(child) {\n    _Node.prototype.appendChild.call(this, child);\n\n    this.root.markDirty();\n  };\n\n  _proto.appendChildBefore = function appendChildBefore(child, beforeChild) {\n    _Node.prototype.appendChildBefore.call(this, child, beforeChild);\n\n    this.root.markDirty();\n  };\n\n  _proto.removeChild = function removeChild(child) {\n    _Node.prototype.removeChild.call(this, child);\n\n    this.root.markDirty();\n  };\n\n  _proto.update = function update(newProps) {\n    this.props = deepMerge([this.constructor.defaultProps, Base.defaultProps, newProps]);\n    this.root.markDirty();\n  };\n\n  _proto.applyProps = function applyProps() {\n    var _this2 = this;\n\n    this.style = this.resolveStyles();\n    toPairsIn(this.style).map(function (_ref) {\n      var attribute = _ref[0],\n          value = _ref[1];\n\n      _this2.applyStyle(attribute, value);\n    });\n    this.children.forEach(function (child) {\n      if (child.applyProps) child.applyProps();\n    });\n  };\n\n  _proto.resolveStyles = function resolveStyles() {\n    var _this$page = this.page,\n        size = _this$page.size,\n        orientation = _this$page.orientation,\n        isAutoHeight = _this$page.isAutoHeight;\n    var container = {\n      orientation: orientation,\n      isAutoHeight: isAutoHeight,\n      width: size.width,\n      height: size.height\n    };\n    var ownStyles = StyleSheet.resolve(this.props.style, container);\n    var inheritedStyles = this.parent ? pick(inheritedProperties, this.parent.style) : {};\n    return _extends({}, inheritedStyles, {}, ownStyles);\n  };\n\n  _proto.applyStyle = function applyStyle(attribute, value) {\n    if (value === undefined) return;\n    var setter = \"set\" + upperFirst(attribute);\n\n    switch (attribute) {\n      case 'marginTop':\n      case 'marginRight':\n      case 'marginBottom':\n      case 'marginLeft':\n      case 'paddingTop':\n      case 'paddingRight':\n      case 'paddingBottom':\n      case 'paddingLeft':\n      case 'borderTopWidth':\n      case 'borderRightWidth':\n      case 'borderBottomWidth':\n      case 'borderLeftWidth':\n      case 'position':\n      case 'top':\n      case 'right':\n      case 'bottom':\n      case 'left':\n      case 'width':\n      case 'height':\n      case 'minHeight':\n      case 'maxHeight':\n      case 'minWidth':\n      case 'maxWidth':\n        this[attribute] = value;\n        break;\n\n      default:\n        if (isFunction(this.layout[setter])) {\n          this.layout[setter](value);\n        }\n\n    }\n  };\n\n  _proto.getLayoutData = function getLayoutData() {\n    var layout = this.getAbsoluteLayout();\n    return {\n      type: this.name,\n      top: layout.top,\n      left: layout.left,\n      width: layout.width,\n      style: this.style,\n      height: layout.height,\n      children: this.children.map(function (c) {\n        return c.getLayoutData();\n      })\n    };\n  };\n\n  _proto.drawBackgroundColor = function drawBackgroundColor() {\n    var _this$style = this.style,\n        backgroundColor = _this$style.backgroundColor,\n        _this$style$opacity = _this$style.opacity,\n        opacity = _this$style$opacity === void 0 ? 1 : _this$style$opacity;\n\n    var _this$getAbsoluteLayo = this.getAbsoluteLayout(),\n        left = _this$getAbsoluteLayo.left,\n        top = _this$getAbsoluteLayo.top,\n        width = _this$getAbsoluteLayo.width,\n        height = _this$getAbsoluteLayo.height;\n\n    if (backgroundColor) {\n      this.root.instance.save();\n      this.clip();\n      this.root.instance.fillOpacity(opacity).fillColor(backgroundColor).rect(left, top, width, height).fill().restore();\n    }\n  };\n\n  _proto.clone = function clone() {\n    var clone = new this.constructor(this.root, this.props);\n    clone.copyStyle(this);\n    clone.style = this.style;\n    return clone;\n  };\n\n  _proto.onNodeSplit = function onNodeSplit(height, clone) {\n    this.calculateLayout();\n    clone.marginTop = 0;\n    clone.paddingTop = 0; // If a height was given to the element, we need to substract the remaining wrapping height\n    // If not, we just let Yoga calculate the appropiate height when layout get's calculated.\n\n    if (clone.style.height) {\n      clone.height = this.height - height;\n    }\n\n    this.height = height;\n    this.marginBottom = 0;\n    this.paddingBottom = 0;\n  };\n\n  _proto.renderChildren =\n  /*#__PURE__*/\n  function () {\n    var _renderChildren = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var i;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              i = 0;\n\n            case 1:\n              if (!(i < this.children.length)) {\n                _context.next = 7;\n                break;\n              }\n\n              _context.next = 4;\n              return this.children[i].render();\n\n            case 4:\n              i++;\n              _context.next = 1;\n              break;\n\n            case 7:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function renderChildren() {\n      return _renderChildren.apply(this, arguments);\n    }\n\n    return renderChildren;\n  }();\n\n  _createClass(Base, [{\n    key: \"page\",\n    get: function get() {\n      return this.parent.page;\n    }\n  }, {\n    key: \"wrap\",\n    get: function get() {\n      return this.props.wrap;\n    }\n  }, {\n    key: \"break\",\n    get: function get() {\n      return this.props[\"break\"];\n    },\n    set: function set(value) {\n      this.props[\"break\"] = value;\n    }\n  }, {\n    key: \"fixed\",\n    get: function get() {\n      return this.props.fixed;\n    }\n  }, {\n    key: \"minPresenceAhead\",\n    get: function get() {\n      return this.props.minPresenceAhead;\n    }\n  }, {\n    key: \"absolute\",\n    get: function get() {\n      return this.props.style.position === 'absolute';\n    }\n  }, {\n    key: \"origin\",\n    get: function get() {\n      var _this$style2 = this.style,\n          transformOriginX = _this$style2.transformOriginX,\n          transformOriginY = _this$style2.transformOriginY;\n\n      var _this$getAbsoluteLayo2 = this.getAbsoluteLayout(),\n          left = _this$getAbsoluteLayo2.left,\n          top = _this$getAbsoluteLayo2.top,\n          width = _this$getAbsoluteLayo2.width,\n          height = _this$getAbsoluteLayo2.height;\n\n      var percentX = matchPercent(transformOriginX);\n      var percentY = matchPercent(transformOriginY);\n      var offsetX = percentX ? width * percentX.percent : transformOriginX;\n      var offsetY = percentY ? height * percentY.percent : transformOriginY;\n      return [left + offsetX, top + offsetY];\n    }\n  }]);\n\n  return Base;\n}(Node);\n\nBase.defaultProps = {\n  style: {\n    borderTopLeftRadius: 0,\n    borderTopRightRadius: 0,\n    borderBottomRightRadius: 0,\n    borderBottomLeftRadius: 0,\n    transformOriginX: '50%',\n    transformOriginY: '50%'\n  },\n  minPresenceAhead: 0\n};\nObject.assign(Base.prototype, Debug);\nObject.assign(Base.prototype, Borders);\nObject.assign(Base.prototype, Clipping);\nObject.assign(Base.prototype, Transformations);\nvar RULER_WIDTH = 13;\nvar RULER_COLOR = 'white';\nvar RULER_FONT_SIZE = 5;\nvar DEFAULT_RULER_STEPS = 50;\nvar LINE_WIDTH = 0.5;\nvar LINE_COLOR = 'gray';\nvar GRID_COLOR = '#ababab';\n\nvar range = function range(max, steps) {\n  return Array.from({\n    length: Math.ceil(max / steps)\n  }, function (_, i) {\n    return i * steps;\n  });\n};\n\nvar matchPercentage = function matchPercentage(value) {\n  var match = matchPercent(value);\n  return match ? 100 / match.value : null;\n};\n\nvar Ruler = {\n  getRulerWidth: function getRulerWidth() {\n    return RULER_WIDTH;\n  },\n  hasHorizontalRuler: function hasHorizontalRuler() {\n    return this.props.ruler || this.props.horizontalRuler;\n  },\n  hasVerticalRuler: function hasVerticalRuler() {\n    return this.props.ruler || this.props.verticalRuler;\n  },\n  getHorizontalSteps: function getHorizontalSteps() {\n    var value = this.props.horizontalRulerSteps || this.props.rulerSteps || DEFAULT_RULER_STEPS;\n\n    if (typeof value === 'string') {\n      var percentage = matchPercentage(value);\n\n      if (percentage) {\n        var width = this.width - (this.hasVerticalRuler() ? RULER_WIDTH : 0);\n        return width / percentage;\n      }\n\n      throw new Error('Page: Invalid horizontal steps value');\n    }\n\n    return value;\n  },\n  getVerticalSteps: function getVerticalSteps() {\n    var value = this.props.verticalRulerSteps || this.props.rulerSteps || DEFAULT_RULER_STEPS;\n\n    if (typeof value === 'string') {\n      var percentage = matchPercentage(value);\n\n      if (percentage) {\n        var height = this.height - (this.hasHorizontalRuler() ? RULER_WIDTH : 0);\n        return height / percentage;\n      }\n\n      throw new Error('Page: Invalid horizontal steps value');\n    }\n\n    return value;\n  },\n  renderRuler: function renderRuler() {\n    var hasHorizontalRuler = this.hasHorizontalRuler();\n    var hasVerticalRuler = this.hasVerticalRuler();\n\n    if (hasHorizontalRuler || hasVerticalRuler) {\n      this.root.instance.save().lineWidth(LINE_WIDTH).fontSize(RULER_FONT_SIZE).opacity(1);\n      if (hasHorizontalRuler) this.drawHorizontalRuler();\n      if (hasVerticalRuler) this.drawVerticalRuler();\n\n      if (hasHorizontalRuler && hasVerticalRuler) {\n        this.root.instance.rect(0, 0, RULER_WIDTH - LINE_WIDTH, RULER_WIDTH - LINE_WIDTH).fill(RULER_COLOR);\n      }\n\n      this.root.instance.restore();\n    }\n  },\n  drawHorizontalRuler: function drawHorizontalRuler() {\n    var _this = this;\n\n    var offset = this.hasVerticalRuler() ? RULER_WIDTH : 0;\n    this.root.instance.rect(offset, 0, this.width, RULER_WIDTH).fill(RULER_COLOR).moveTo(this.hasVerticalRuler() ? RULER_WIDTH : 0, RULER_WIDTH).lineTo(this.width, RULER_WIDTH).stroke(LINE_COLOR);\n    var hRange = range(this.width, this.getHorizontalSteps());\n    hRange.map(function (step) {\n      _this.root.instance.moveTo(offset + step, 0).lineTo(offset + step, RULER_WIDTH).stroke(LINE_COLOR).fillColor('black').text(\"\" + Math.round(step), offset + step + 1, 1);\n    });\n    hRange.map(function (step) {\n      if (step !== 0) {\n        _this.root.instance.moveTo(offset + step, RULER_WIDTH).lineTo(offset + step, _this.height).stroke(GRID_COLOR);\n      }\n    });\n  },\n  drawVerticalRuler: function drawVerticalRuler() {\n    var _this2 = this;\n\n    var offset = this.hasHorizontalRuler() ? RULER_WIDTH : 0;\n    this.root.instance.rect(0, offset, RULER_WIDTH, this.height).fill(RULER_COLOR).moveTo(RULER_WIDTH, this.hasHorizontalRuler() ? RULER_WIDTH : 0).lineTo(RULER_WIDTH, this.height).stroke(LINE_COLOR);\n    var vRange = range(this.height, this.getVerticalSteps());\n    vRange.map(function (step) {\n      _this2.root.instance.moveTo(0, offset + step).lineTo(RULER_WIDTH, offset + step).stroke(LINE_COLOR).fillColor('black').text(\"\" + Math.round(step), 1, offset + step + 1);\n    });\n    vRange.map(function (step) {\n      if (step !== 0) {\n        _this2.root.instance.moveTo(RULER_WIDTH, offset + step).lineTo(_this2.width, offset + step).stroke(GRID_COLOR);\n      }\n    });\n  }\n};\n\nvar TextInstance =\n/*#__PURE__*/\nfunction () {\n  function TextInstance(root, value) {\n    this.root = root;\n    this.value = value;\n    this.parent = null;\n    this.props = {};\n  }\n\n  var _proto = TextInstance.prototype;\n\n  _proto.getLayoutData = function getLayoutData() {\n    return this.value;\n  };\n\n  _proto.remove = function remove() {\n    this.parent.removeChild(this);\n  };\n\n  _proto.clone = function clone() {\n    return new this.constructor(this.root, this.value);\n  };\n\n  _proto.cleanup = function cleanup() {};\n\n  _proto.update = function update(value) {\n    this.value = value;\n    this.parent.computed = false;\n    this.parent.container = null;\n    this.root.markDirty();\n  };\n\n  _createClass(TextInstance, [{\n    key: \"name\",\n    get: function get() {\n      return 'TextInstance';\n    }\n  }]);\n\n  return TextInstance;\n}();\n\nvar PAGE_SIZES = {\n  '4A0': [4767.87, 6740.79],\n  '2A0': [3370.39, 4767.87],\n  A0: [2383.94, 3370.39],\n  A1: [1683.78, 2383.94],\n  A2: [1190.55, 1683.78],\n  A3: [841.89, 1190.55],\n  A4: [595.28, 841.89],\n  A5: [419.53, 595.28],\n  A6: [297.64, 419.53],\n  A7: [209.76, 297.64],\n  A8: [147.4, 209.76],\n  A9: [104.88, 147.4],\n  A10: [73.7, 104.88],\n  B0: [2834.65, 4008.19],\n  B1: [2004.09, 2834.65],\n  B2: [1417.32, 2004.09],\n  B3: [1000.63, 1417.32],\n  B4: [708.66, 1000.63],\n  B5: [498.9, 708.66],\n  B6: [354.33, 498.9],\n  B7: [249.45, 354.33],\n  B8: [175.75, 249.45],\n  B9: [124.72, 175.75],\n  B10: [87.87, 124.72],\n  C0: [2599.37, 3676.54],\n  C1: [1836.85, 2599.37],\n  C2: [1298.27, 1836.85],\n  C3: [918.43, 1298.27],\n  C4: [649.13, 918.43],\n  C5: [459.21, 649.13],\n  C6: [323.15, 459.21],\n  C7: [229.61, 323.15],\n  C8: [161.57, 229.61],\n  C9: [113.39, 161.57],\n  C10: [79.37, 113.39],\n  RA0: [2437.8, 3458.27],\n  RA1: [1729.13, 2437.8],\n  RA2: [1218.9, 1729.13],\n  RA3: [864.57, 1218.9],\n  RA4: [609.45, 864.57],\n  SRA0: [2551.18, 3628.35],\n  SRA1: [1814.17, 2551.18],\n  SRA2: [1275.59, 1814.17],\n  SRA3: [907.09, 1275.59],\n  SRA4: [637.8, 907.09],\n  EXECUTIVE: [521.86, 756.0],\n  FOLIO: [612.0, 936.0],\n  LEGAL: [612.0, 1008.0],\n  LETTER: [612.0, 792.0],\n  TABLOID: [792.0, 1224.0]\n}; // Return page size in an object { width, height } given the passed size and orientation\n// Accepts page type string, number, array or object as parameter\n\nvar getPageSize = function getPageSize(size, orientation) {\n  if (orientation === void 0) {\n    orientation = 'portrait';\n  }\n\n  var result;\n\n  if (typeof size === 'string') {\n    result = PAGE_SIZES[size.toUpperCase()];\n  } else if (Array.isArray(size)) {\n    result = size;\n  } else if (typeof size === 'number') {\n    result = [size];\n  } else if (typeof size === 'object' && size.width) {\n    result = [size.width, size.height];\n  } else {\n    throw new Error(\"Invalid Page size: \" + size);\n  }\n\n  return orientation === 'portrait' ? {\n    width: result[0],\n    height: result[1]\n  } : {\n    width: result[1],\n    height: result[0]\n  };\n};\n\nvar PROTOCOL_REGEXP = /^([a-z]+\\:(\\/\\/)?)/i;\nvar DEST_REGEXP = /^#.+/;\n\nvar getURL = function getURL(value) {\n  if (!value) return '';\n  if (isSrcId(value)) return value; // don't modify it if it is an id\n\n  if (typeof value === 'string' && !value.match(PROTOCOL_REGEXP)) {\n    return \"http://\" + value;\n  }\n\n  return value;\n};\n\nvar isSrcId = function isSrcId(src) {\n  return src.match(DEST_REGEXP);\n};\n\nvar setLink = function setLink(node) {\n  if (!node.src) {\n    return;\n  }\n\n  var _node$getAbsoluteLayo = node.getAbsoluteLayout(),\n      top = _node$getAbsoluteLayo.top,\n      left = _node$getAbsoluteLayo.left,\n      width = _node$getAbsoluteLayo.width,\n      height = _node$getAbsoluteLayo.height;\n\n  var instanceMethod = isSrcId(node.src) ? 'goTo' : 'link';\n  var nodeSrc = isSrcId(node.src) ? node.src.slice(1) : node.src;\n  node.root.instance[instanceMethod](left, top, width, height, nodeSrc);\n};\n\nvar setDestination = function setDestination(node) {\n  if (!node.props.id) {\n    return;\n  }\n\n  var _node$getAbsoluteLayo2 = node.getAbsoluteLayout(),\n      top = _node$getAbsoluteLayo2.top;\n\n  node.root.instance.addNamedDestination(node.props.id, 'XYZ', null, top, null);\n};\n\nvar Page =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Page, _Base);\n\n  function Page(root, props) {\n    var _this;\n\n    _this = _Base.call(this, root, props) || this;\n    _this._size = null;\n    return _this;\n  }\n\n  var _proto = Page.prototype;\n\n  _proto.resetMargins = function resetMargins() {\n    if (!!this.marginTop || !!this.marginBottom || !!this.marginLeft || !!this.marginRight) {\n      warning(false, 'Margin values are not allowed on Page element. Use padding instead.');\n      this.marginTop = 0;\n      this.marginBottom = 0;\n      this.marginLeft = 0;\n      this.marginRight = 0;\n    }\n  };\n\n  _proto.applyProps = function applyProps() {\n    _Base.prototype.applyProps.call(this);\n\n    this.top = 0;\n    this.left = 0;\n    this.width = this.size.width;\n    this.resetMargins(); // Add some padding if ruler present, so we can see the whole page inside it\n\n    var rulerWidth = this.getRulerWidth();\n\n    if (this.hasHorizontalRuler()) {\n      this.paddingTop = this.paddingTop + rulerWidth;\n    }\n\n    if (this.hasVerticalRuler()) {\n      this.paddingLeft = this.paddingLeft + rulerWidth;\n    }\n  };\n\n  _proto.setPadding = function setPadding(edge, value) {\n    var dimension = edge === Yoga.EDGE_TOP || edge === Yoga.EDGE_BOTTOM ? this.size.height : this.size.width;\n    var match = matchPercent(value);\n\n    if (match) {\n      this.layout.setPadding(edge, dimension * match.percent);\n    } else {\n      this.layout.setPadding(edge, value);\n    }\n  };\n\n  _proto.addDynamicChild =\n  /*#__PURE__*/\n  function () {\n    var _addDynamicChild = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee(parent, elements) {\n      var children, i, child, type, props, instance, _instance;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              if (elements) {\n                _context.next = 2;\n                break;\n              }\n\n              return _context.abrupt(\"return\");\n\n            case 2:\n              children = Array.isArray(elements) ? elements : [elements];\n              i = 0;\n\n            case 4:\n              if (!(i < children.length)) {\n                _context.next = 27;\n                break;\n              }\n\n              child = children[i];\n              type = child.type, props = child.props;\n\n              if (!(typeof child === 'string')) {\n                _context.next = 12;\n                break;\n              }\n\n              instance = new TextInstance(this.root, child);\n              parent.appendChild(instance);\n              _context.next = 24;\n              break;\n\n            case 12:\n              if (!(type !== Fragment)) {\n                _context.next = 22;\n                break;\n              }\n\n              _instance = createInstance(child, this.root);\n              _context.next = 16;\n              return _instance.onAppendDynamically();\n\n            case 16:\n              parent.appendChild(_instance);\n\n              _instance.applyProps();\n\n              _context.next = 20;\n              return this.addDynamicChild(_instance, props.children);\n\n            case 20:\n              _context.next = 24;\n              break;\n\n            case 22:\n              _context.next = 24;\n              return this.addDynamicChild(parent, props.children);\n\n            case 24:\n              i++;\n              _context.next = 4;\n              break;\n\n            case 27:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function addDynamicChild(_x, _x2) {\n      return _addDynamicChild.apply(this, arguments);\n    }\n\n    return addDynamicChild;\n  }();\n\n  _proto.renderDynamicNodes =\n  /*#__PURE__*/\n  function () {\n    var _renderDynamicNodes = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2(props, cb) {\n      var listToExplore, node, condition, elements;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              listToExplore = this.children.slice(0);\n\n            case 1:\n              if (!(listToExplore.length > 0)) {\n                _context2.next = 14;\n                break;\n              }\n\n              node = listToExplore.shift();\n              condition = cb ? cb(node) : true;\n\n              if (!(condition && node.props.render)) {\n                _context2.next = 11;\n                break;\n              }\n\n              node.removeAllChilds();\n              elements = node.props.render(props);\n              _context2.next = 9;\n              return this.addDynamicChild(node, elements);\n\n            case 9:\n              if (!node.fixed) node.props.render = null;\n              return _context2.abrupt(\"continue\", 1);\n\n            case 11:\n              if (node.children) {\n                listToExplore.push.apply(listToExplore, node.children);\n              }\n\n              _context2.next = 1;\n              break;\n\n            case 14:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function renderDynamicNodes(_x3, _x4) {\n      return _renderDynamicNodes.apply(this, arguments);\n    }\n\n    return renderDynamicNodes;\n  }();\n\n  _proto.nodeWillWrap =\n  /*#__PURE__*/\n  function () {\n    var _nodeWillWrap = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3(props) {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              _context3.next = 2;\n              return this.renderDynamicNodes(props);\n\n            case 2:\n              this.calculateLayout();\n\n            case 3:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    function nodeWillWrap(_x5) {\n      return _nodeWillWrap.apply(this, arguments);\n    }\n\n    return nodeWillWrap;\n  }();\n\n  _proto.onNodeSplit = function onNodeSplit(height, clone) {\n    clone.marginTop = 0;\n    this.marginBottom = 0;\n    this.calculateLayout();\n  };\n\n  _proto.clone = function clone() {\n    var clone = _Base.prototype.clone.call(this);\n\n    clone._size = this.size;\n    return clone;\n  };\n\n  _proto.update = function update(newProps) {\n    _Base.prototype.update.call(this, newProps);\n\n    this._size = null;\n  };\n\n  _proto.render =\n  /*#__PURE__*/\n  function () {\n    var _render = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4() {\n      var instance, height;\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              instance = this.root.instance;\n\n              if (!this.isAutoHeight) {\n                this.height = this.size.height;\n              }\n\n              this.calculateLayout();\n              height = this.isAutoHeight ? this.height : this.size.height;\n              instance.addPage({\n                size: [this.size.width, height],\n                margin: 0\n              });\n              setDestination(this);\n\n              if (this.style.backgroundColor) {\n                instance.fillColor(this.style.backgroundColor).rect(0, 0, this.size.width, height).fill();\n              }\n\n              _context4.next = 9;\n              return this.renderChildren();\n\n            case 9:\n              if (this.props.debug) {\n                this.debug();\n              }\n\n              this.renderRuler();\n\n            case 11:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n\n    function render() {\n      return _render.apply(this, arguments);\n    }\n\n    return render;\n  }();\n\n  _createClass(Page, [{\n    key: \"name\",\n    get: function get() {\n      return 'Page';\n    }\n  }, {\n    key: \"document\",\n    get: function get() {\n      return this.parent;\n    }\n  }, {\n    key: \"page\",\n    get: function get() {\n      return this;\n    }\n  }, {\n    key: \"orientation\",\n    get: function get() {\n      return this.props.orientation;\n    }\n  }, {\n    key: \"size\",\n    get: function get() {\n      if (this._size) return this._size;\n      this._size = getPageSize(this.props.size, this.orientation); // Adjust size for ruler\n\n      if (this.hasHorizontalRuler()) {\n        this._size.width += this.getRulerWidth();\n      }\n\n      if (this.hasVerticalRuler()) {\n        this._size.height += this.getRulerWidth();\n      }\n\n      return this._size;\n    }\n  }, {\n    key: \"isAutoHeight\",\n    get: function get() {\n      return typeof this.size.height === 'undefined';\n    }\n  }]);\n\n  return Page;\n}(Base);\n\nPage.defaultProps = {\n  size: 'A4',\n  wrap: true,\n  orientation: 'portrait'\n};\nObject.assign(Page.prototype, Ruler);\n\nvar View =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(View, _Base);\n\n  function View() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = View.prototype;\n\n  _proto.render =\n  /*#__PURE__*/\n  function () {\n    var _render = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this.root.instance.save();\n              this.applyTransformations();\n              this.drawBackgroundColor();\n              this.drawBorders();\n              _context.next = 6;\n              return this.renderChildren();\n\n            case 6:\n              setDestination(this);\n              if (this.props.debug) this.debug();\n              this.root.instance.restore();\n\n            case 9:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function render() {\n      return _render.apply(this, arguments);\n    }\n\n    return render;\n  }();\n\n  _createClass(View, [{\n    key: \"name\",\n    get: function get() {\n      return 'View';\n    }\n  }]);\n\n  return View;\n}(Base);\n\nView.defaultProps = {\n  wrap: true\n};\n\nvar fetchFont =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(src, options) {\n    var response, buffer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(src, options);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.buffer ? response.buffer() : response.arrayBuffer();\n\n          case 5:\n            buffer = _context.sent;\n            return _context.abrupt(\"return\", buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchFont(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar FontSource =\n/*#__PURE__*/\nfunction () {\n  function FontSource(src, fontFamily, fontStyle, fontWeight, options) {\n    this.src = src;\n    this.fontFamily = fontFamily;\n    this.fontStyle = fontStyle || 'normal';\n    this.fontWeight = processFontWeight(fontWeight) || 400;\n    this.data = null;\n    this.loading = false;\n    this.options = options;\n  }\n\n  var _proto = FontSource.prototype;\n\n  _proto.load =\n  /*#__PURE__*/\n  function () {\n    var _load = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2() {\n      var _this = this;\n\n      var _this$options, headers, body, _this$options$method, method, data;\n\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              this.loading = true;\n              _this$options = this.options, headers = _this$options.headers, body = _this$options.body, _this$options$method = _this$options.method, method = _this$options$method === void 0 ? 'GET' : _this$options$method;\n              _context2.next = 5;\n              return fetchFont(this.src, {\n                method: method,\n                body: body,\n                headers: headers\n              });\n\n            case 5:\n              data = _context2.sent;\n              this.data = fontkit.create(data);\n              _context2.next = 12;\n              break;\n\n            case 9:\n              _context2.next = 11;\n              return new Promise(function (resolve, reject) {\n                return fontkit.open(_this.src, function (err, data) {\n                  return err ? reject(err) : resolve(data);\n                });\n              });\n\n            case 11:\n              this.data = _context2.sent;\n\n            case 12:\n              this.loading = false;\n\n            case 13:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function load() {\n      return _load.apply(this, arguments);\n    }\n\n    return load;\n  }();\n\n  return FontSource;\n}();\n\nvar Font =\n/*#__PURE__*/\nfunction () {\n  Font.create = function create(family) {\n    return new Font(family);\n  };\n\n  function Font(family) {\n    this.family = family;\n    this.sources = [];\n  }\n\n  var _proto2 = Font.prototype;\n\n  _proto2.register = function register(_ref2) {\n    var src = _ref2.src,\n        fontWeight = _ref2.fontWeight,\n        fontStyle = _ref2.fontStyle,\n        options = _objectWithoutPropertiesLoose(_ref2, [\"src\", \"fontWeight\", \"fontStyle\"]);\n\n    this.sources.push(new FontSource(src, this.fontFamily, fontStyle, fontWeight, options));\n  };\n\n  _proto2.resolve = function resolve(descriptor) {\n    var _descriptor$fontWeigh = descriptor.fontWeight,\n        fontWeight = _descriptor$fontWeigh === void 0 ? 400 : _descriptor$fontWeigh,\n        _descriptor$fontStyle = descriptor.fontStyle,\n        fontStyle = _descriptor$fontStyle === void 0 ? 'normal' : _descriptor$fontStyle;\n    var styleSources = this.sources.filter(function (s) {\n      return s.fontStyle === fontStyle;\n    }); // Weight resolution. https://developer.mozilla.org/en-US/docs/Web/CSS/font-weight#Fallback_weights\n\n    var exactFit = styleSources.find(function (s) {\n      return s.fontWeight === fontWeight;\n    });\n    if (exactFit) return exactFit;\n    var res;\n\n    if (fontWeight >= 400 && fontWeight <= 500) {\n      var leftOffset = styleSources.filter(function (s) {\n        return s.fontWeight <= fontWeight;\n      });\n      var rightOffset = styleSources.filter(function (s) {\n        return s.fontWeight > 500;\n      });\n      var fit = styleSources.filter(function (s) {\n        return s.fontWeight >= fontWeight && s.fontWeight < 500;\n      });\n      res = fit[0] || leftOffset[leftOffset.length - 1] || rightOffset[0];\n    }\n\n    var lt = styleSources.filter(function (s) {\n      return s.fontWeight < fontWeight;\n    });\n    var gt = styleSources.filter(function (s) {\n      return s.fontWeight > fontWeight;\n    });\n\n    if (fontWeight < 400) {\n      res = lt[lt.length - 1] || gt[0];\n    }\n\n    if (fontWeight > 500) {\n      res = gt[0] || lt[lt.length - 1];\n    }\n\n    if (!res) {\n      throw new Error(\"Could not resolve font for \" + this.fontFamily + \", fontWeight \" + fontWeight);\n    }\n\n    return res;\n  };\n\n  return Font;\n}();\n\nvar emojiSource;\n\nvar registerEmojiSource = function registerEmojiSource(_ref) {\n  var url = _ref.url,\n      _ref$format = _ref.format,\n      format = _ref$format === void 0 ? 'png' : _ref$format;\n  emojiSource = {\n    url: url,\n    format: format\n  };\n};\n\nvar getEmojiSource = function getEmojiSource() {\n  return emojiSource;\n};\n\nvar emoji = {\n  registerEmojiSource: registerEmojiSource,\n  getEmojiSource: getEmojiSource\n};\nvar standardFonts = ['Courier', 'Courier-Bold', 'Courier-Oblique', 'Helvetica', 'Helvetica-Bold', 'Helvetica-Oblique', 'Times-Roman', 'Times-Bold', 'Times-Italic'];\nvar hyphenationCallback;\n\nvar registerHyphenationCallback = function registerHyphenationCallback(callback) {\n  hyphenationCallback = callback;\n};\n\nvar getHyphenationCallback = function getHyphenationCallback() {\n  return hyphenationCallback;\n};\n\nvar hyphenation = {\n  registerHyphenationCallback: registerHyphenationCallback,\n  getHyphenationCallback: getHyphenationCallback\n};\nvar fonts = {};\n\nvar register = function register(src, data) {\n  if (typeof src === 'object') {\n    data = src;\n  } else {\n    warning(false, 'Font.register will not longer accept the font source as first argument. Please move it into the data object. For more info refer to https://react-pdf.org/fonts');\n    data.src = src;\n  }\n\n  var _data = data,\n      family = _data.family;\n\n  if (!fonts[family]) {\n    fonts[family] = Font.create(family);\n  } // Bulk loading\n\n\n  if (data.fonts) {\n    for (var i = 0; i < data.fonts.length; i++) {\n      fonts[family].register(_extends({\n        family: family\n      }, data.fonts[i]));\n    }\n  } else {\n    fonts[family].register(data);\n  }\n};\n\nvar getRegisteredFonts = function getRegisteredFonts() {\n  return fonts;\n};\n\nvar getRegisteredFontFamilies = function getRegisteredFontFamilies() {\n  return Object.keys(fonts);\n};\n\nvar getFont = function getFont(descriptor) {\n  var fontFamily = descriptor.fontFamily;\n  var isStandard = standardFonts.includes(fontFamily);\n  if (isStandard) return null;\n\n  if (!fonts[fontFamily]) {\n    throw new Error(\"Font family not registered: \" + fontFamily + \". Please register it calling Font.register() method.\");\n  }\n\n  return fonts[fontFamily].resolve(descriptor);\n};\n\nvar load =\n/*#__PURE__*/\nfunction () {\n  var _ref = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(descriptor, doc) {\n    var fontFamily, isStandard, font;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            fontFamily = descriptor.fontFamily;\n            isStandard = standardFonts.includes(fontFamily);\n\n            if (!isStandard) {\n              _context.next = 4;\n              break;\n            }\n\n            return _context.abrupt(\"return\");\n\n          case 4:\n            font = getFont(descriptor); // We cache the font to avoid fetching it many times\n\n            if (!(!font.data && !font.loading)) {\n              _context.next = 8;\n              break;\n            }\n\n            _context.next = 8;\n            return font.load();\n\n          case 8:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function load(_x, _x2) {\n    return _ref.apply(this, arguments);\n  };\n}();\n\nvar reset = function reset() {\n  for (var _font in fonts) {\n    if (fonts.hasOwnProperty(_font)) {\n      fonts[_font].data = null;\n    }\n  }\n};\n\nvar clear = function clear() {\n  fonts = {};\n};\n\nvar Font$1 = _extends({\n  register: register,\n  getRegisteredFonts: getRegisteredFonts,\n  getRegisteredFontFamilies: getRegisteredFontFamilies,\n  getFont: getFont,\n  load: load,\n  clear: clear,\n  reset: reset\n}, emoji, {}, hyphenation);\n\nvar StandardFont =\n/*#__PURE__*/\nfunction () {\n  function StandardFont(src) {\n    this.name = src;\n    this.src = PDFFont.open(null, src);\n  }\n\n  var _proto = StandardFont.prototype;\n\n  _proto.layout = function layout(str) {\n    var _this = this;\n\n    var _this$src$encode = this.src.encode(str),\n        encoded = _this$src$encode[0],\n        positions = _this$src$encode[1];\n\n    return {\n      positions: positions,\n      stringIndices: positions.map(function (_, i) {\n        return i;\n      }),\n      glyphs: encoded.map(function (g, i) {\n        var glyph = _this.getGlyph(parseInt(g, 16));\n\n        glyph.advanceWidth = positions[i].advanceWidth;\n        return glyph;\n      })\n    };\n  };\n\n  _proto.glyphForCodePoint = function glyphForCodePoint(codePoint) {\n    var glyph = this.getGlyph(codePoint);\n    glyph.advanceWidth = 400;\n    return glyph;\n  };\n\n  _proto.getGlyph = function getGlyph(id) {\n    return {\n      id: id,\n      _font: this.src,\n      codePoints: [id],\n      isLigature: false,\n      name: this.src.font.characterToGlyph(id)\n    };\n  };\n\n  _proto.hasGlyphForCodePoint = function hasGlyphForCodePoint(codePoint) {\n    return this.src.font.characterToGlyph(codePoint) !== '.notdef';\n  } // Based on empirical observation\n  ;\n\n  _createClass(StandardFont, [{\n    key: \"ascent\",\n    get: function get() {\n      return 900;\n    } // Based on empirical observation\n\n  }, {\n    key: \"descent\",\n    get: function get() {\n      switch (this.name) {\n        case 'Times-Roman':\n        case 'Times-Bold':\n        case 'Times-Italic':\n          return -220;\n\n        case 'Courier':\n        case 'Courier-Bold':\n        case 'Courier-Oblique':\n          return -230;\n\n        default:\n          return -200;\n      }\n    }\n  }, {\n    key: \"lineGap\",\n    get: function get() {\n      return 0;\n    }\n  }, {\n    key: \"unitsPerEm\",\n    get: function get() {\n      return 1000;\n    }\n  }]);\n\n  return StandardFont;\n}();\n\nvar fontCache = {};\nvar IGNORED_CODE_POINTS = [173];\nvar getFontSize = pathOr(12, ['attributes', 'fontSize']);\n\nvar getFallbackFont = function getFallbackFont() {\n  return getOrCreateFont('Helvetica');\n};\n\nvar getOrCreateFont = function getOrCreateFont(name) {\n  if (fontCache[name]) return fontCache[name];\n  var font = new StandardFont(name);\n  fontCache[name] = font;\n  return font;\n};\n\nvar shouldFallbackToFont = function shouldFallbackToFont(codePoint, font) {\n  return !IGNORED_CODE_POINTS.includes(codePoint) && !font.hasGlyphForCodePoint(codePoint) && getFallbackFont().hasGlyphForCodePoint(codePoint);\n};\n\nvar fontSubstitution = function fontSubstitution() {\n  return function (_ref) {\n    var string = _ref.string,\n        runs = _ref.runs;\n    var lastFont = null;\n    var lastIndex = 0;\n    var index = 0;\n    var res = [];\n\n    for (var _iterator = runs, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n      var _ref2;\n\n      if (_isArray) {\n        if (_i >= _iterator.length) break;\n        _ref2 = _iterator[_i++];\n      } else {\n        _i = _iterator.next();\n        if (_i.done) break;\n        _ref2 = _i.value;\n      }\n\n      var run = _ref2;\n\n      var _fontSize = getFontSize(run);\n\n      var defaultFont = typeof run.attributes.font === 'string' ? getOrCreateFont(run.attributes.font) : run.attributes.font;\n\n      if (string.length === 0) {\n        res.push({\n          start: 0,\n          end: 0,\n          attributes: {\n            font: defaultFont\n          }\n        });\n        break;\n      }\n\n      for (var _iterator2 = string.slice(run.start, run.end), _isArray2 = Array.isArray(_iterator2), _i2 = 0, _iterator2 = _isArray2 ? _iterator2 : _iterator2[Symbol.iterator]();;) {\n        var _ref3;\n\n        if (_isArray2) {\n          if (_i2 >= _iterator2.length) break;\n          _ref3 = _iterator2[_i2++];\n        } else {\n          _i2 = _iterator2.next();\n          if (_i2.done) break;\n          _ref3 = _i2.value;\n        }\n\n        var _char = _ref3;\n\n        var codePoint = _char.codePointAt();\n\n        var shouldFallback = shouldFallbackToFont(codePoint, defaultFont);\n        var font = shouldFallback ? getFallbackFont() : defaultFont; // If the default font does not have a glyph and the fallback font does, we use it\n\n        if (font !== lastFont) {\n          if (lastFont) {\n            res.push({\n              start: lastIndex,\n              end: index,\n              attributes: {\n                font: lastFont,\n                scale: lastFont ? _fontSize / lastFont.unitsPerEm : 0\n              }\n            });\n          }\n\n          lastFont = font;\n          lastIndex = index;\n        }\n\n        index += _char.length;\n      }\n    }\n\n    if (lastIndex < string.length) {\n      var fontSize = getFontSize(last(runs));\n      res.push({\n        start: lastIndex,\n        end: string.length,\n        attributes: {\n          font: lastFont,\n          scale: lastFont ? fontSize / lastFont.unitsPerEm : 0\n        }\n      });\n    }\n\n    return {\n      string: string,\n      runs: res\n    };\n  };\n};\n\nvar engines = {\n  linebreaker: linebreaker,\n  justification: justification,\n  textDecoration: textDecoration,\n  scriptItemizer: scriptItemizer,\n  wordHyphenation: wordHyphenation,\n  fontSubstitution: fontSubstitution\n};\nvar engine = layoutEngine(engines);\n\nPNG.isValid = function (data) {\n  try {\n    return !!new PNG(data);\n  } catch (e) {\n    return false;\n  }\n}; // Extracted from https://github.com/devongovett/pdfkit/blob/master/lib/image/jpeg.coffee\n\n\nvar MARKERS = [0xffc0, 0xffc1, 0xffc2, 0xffc3, 0xffc5, 0xffc6, 0xffc7, 0xffc8, 0xffc9, 0xffca, 0xffcb, 0xffcc, 0xffcd, 0xffce, 0xffcf];\n\nvar JPEG = function JPEG(data) {\n  this.data = null;\n  this.width = null;\n  this.height = null;\n  this.data = data;\n\n  if (data.readUInt16BE(0) !== 0xffd8) {\n    throw new Error('SOI not found in JPEG');\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    throw new Error('Invalid JPEG.');\n  }\n\n  pos += 3;\n  this.height = data.readUInt16BE(pos);\n  pos += 2;\n  this.width = data.readUInt16BE(pos);\n};\n\nJPEG.isValid = function (data) {\n  if (!data || !Buffer.isBuffer(data) || data.readUInt16BE(0) !== 0xffd8) {\n    return false;\n  }\n\n  var marker;\n  var pos = 2;\n\n  while (pos < data.length) {\n    marker = data.readUInt16BE(pos);\n    pos += 2;\n\n    if (MARKERS.includes(marker)) {\n      break;\n    }\n\n    pos += data.readUInt16BE(pos);\n  }\n\n  if (!MARKERS.includes(marker)) {\n    return false;\n  }\n\n  return true;\n};\n\nvar createCache = function createCache(_temp) {\n  var _ref = _temp === void 0 ? {} : _temp,\n      _ref$limit = _ref.limit,\n      limit = _ref$limit === void 0 ? 100 : _ref$limit;\n\n  var cache = {};\n  var keys = [];\n  return {\n    get: function get(key) {\n      return cache[key];\n    },\n    set: function set(key, value) {\n      keys.push(key);\n\n      if (keys.length > limit) {\n        delete cache[keys.shift()];\n      }\n\n      cache[key] = value;\n    },\n    reset: function reset() {\n      cache = {};\n      keys = [];\n    },\n    length: function length() {\n      return keys.length;\n    }\n  };\n};\n\nvar IMAGE_CACHE = createCache({\n  limit: 30\n});\n\nvar fetchRemoteFile =\n/*#__PURE__*/\nfunction () {\n  var _ref3 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee(uri, options) {\n    var response, buffer;\n    return _regeneratorRuntime.wrap(function _callee$(_context) {\n      while (1) {\n        switch (_context.prev = _context.next) {\n          case 0:\n            _context.next = 2;\n            return fetch(uri, options);\n\n          case 2:\n            response = _context.sent;\n            _context.next = 5;\n            return response.buffer ? response.buffer() : response.arrayBuffer();\n\n          case 5:\n            buffer = _context.sent;\n            return _context.abrupt(\"return\", buffer.constructor.name === 'Buffer' ? buffer : Buffer.from(buffer));\n\n          case 7:\n          case \"end\":\n            return _context.stop();\n        }\n      }\n    }, _callee);\n  }));\n\n  return function fetchRemoteFile(_x, _x2) {\n    return _ref3.apply(this, arguments);\n  };\n}();\n\nvar isValidFormat = function isValidFormat(format) {\n  var lower = format.toLowerCase();\n  return lower === 'jpg' || lower === 'jpeg' || lower === 'png';\n};\n\nvar guessFormat = function guessFormat(buffer) {\n  var format;\n\n  if (JPEG.isValid(buffer)) {\n    format = 'jpg';\n  } else if (PNG.isValid(buffer)) {\n    format = 'png';\n  }\n\n  return format;\n};\n\nvar isCompatibleBase64 = function isCompatibleBase64(_ref4) {\n  var uri = _ref4.uri;\n  return /^data:image\\/[a-zA-Z]*;base64,[^\"]*/g.test(uri);\n};\n\nfunction getImage(body, extension) {\n  switch (extension.toLowerCase()) {\n    case 'jpg':\n    case 'jpeg':\n      return new JPEG(body);\n\n    case 'png':\n      return new PNG(body);\n\n    default:\n      return null;\n  }\n}\n\nvar resolveBase64Image = function resolveBase64Image(_ref5) {\n  var uri = _ref5.uri;\n  var match = /^data:image\\/([a-zA-Z]*);base64,([^\"]*)/g.exec(uri);\n  var format = match[1];\n  var data = match[2];\n\n  if (!isValidFormat(format)) {\n    throw new Error(\"Base64 image invalid format: \" + format);\n  }\n\n  return new Promise(function (resolve) {\n    return resolve(getImage(Buffer.from(data, 'base64'), format));\n  });\n};\n\nvar resolveImageFromData = function resolveImageFromData(src) {\n  if (src.data && src.format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(src.data, src.format));\n    });\n  }\n\n  throw new Error(\"Invalid data given for local file: \" + JSON.stringify(src));\n};\n\nvar resolveBufferImage = function resolveBufferImage(buffer) {\n  var format = guessFormat(buffer);\n\n  if (format) {\n    return new Promise(function (resolve) {\n      return resolve(getImage(buffer, format));\n    });\n  }\n};\n\nvar getImageFormat = function getImageFormat(body) {\n  var isPng = body[0] === 137 && body[1] === 80 && body[2] === 78 && body[3] === 71 && body[4] === 13 && body[5] === 10 && body[6] === 26 && body[7] === 10;\n  var isJpg = body[0] === 255 && body[1] === 216 && body[2] === 255;\n  var extension = '';\n\n  if (isPng) {\n    extension = 'png';\n  } else if (isJpg) {\n    extension = 'jpg';\n  } else {\n    throw new Error('Not valid image extension');\n  }\n\n  return extension;\n};\n\nvar resolveImageFromUrl =\n/*#__PURE__*/\nfunction () {\n  var _ref6 = _asyncToGenerator(\n  /*#__PURE__*/\n  _regeneratorRuntime.mark(function _callee2(src, options) {\n    var uri, body, headers, _src$method, method, data, extension;\n\n    return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n      while (1) {\n        switch (_context2.prev = _context2.next) {\n          case 0:\n            uri = src.uri, body = src.body, headers = src.headers, _src$method = src.method, method = _src$method === void 0 ? 'GET' : _src$method;\n            {\n              _context2.next = 7;\n              break;\n            }\n\n          case 4:\n            _context2.t0 = _context2.sent;\n            _context2.next = 10;\n            break;\n\n          case 7:\n            _context2.next = 9;\n            return fetchRemoteFile(uri, {\n              body: body,\n              headers: headers,\n              method: method\n            });\n\n          case 9:\n            _context2.t0 = _context2.sent;\n\n          case 10:\n            data = _context2.t0;\n            extension = getImageFormat(data);\n            return _context2.abrupt(\"return\", getImage(data, extension));\n\n          case 13:\n          case \"end\":\n            return _context2.stop();\n        }\n      }\n    }, _callee2);\n  }));\n\n  return function resolveImageFromUrl(_x3, _x4) {\n    return _ref6.apply(this, arguments);\n  };\n}();\n\nvar resolveImage = function resolveImage(src, _temp3) {\n  var _ref7 = _temp3 === void 0 ? {} : _temp3,\n      _ref7$cache = _ref7.cache,\n      cache = _ref7$cache === void 0 ? true : _ref7$cache,\n      options = _objectWithoutPropertiesLoose(_ref7, [\"cache\"]);\n\n  var cacheKey = src.data ? src.data.toString() : src.uri;\n\n  if (cache && IMAGE_CACHE.get(cacheKey)) {\n    return IMAGE_CACHE.get(cacheKey);\n  }\n\n  var image;\n\n  if (isCompatibleBase64(src)) {\n    image = resolveBase64Image(src);\n  } else if (Buffer.isBuffer(src)) {\n    image = resolveBufferImage(src);\n  } else if (typeof src === 'object' && src.data) {\n    image = resolveImageFromData(src);\n  } else {\n    image = resolveImageFromUrl(src, options);\n  }\n\n  if (!image) {\n    throw new Error('Cannot resolve image');\n  }\n\n  if (cache) {\n    IMAGE_CACHE.set(cacheKey, image);\n  }\n\n  return image;\n};\n\nvar emojis = {};\nvar regex = emojiRegex();\n\nvar reflect = function reflect(promise) {\n  return function () {\n    return promise.apply(void 0, arguments).then(function (v) {\n      return v;\n    }, function (e) {\n      return e;\n    });\n  };\n}; // Returns a function to be able to mock resolveImage.\n\n\nvar makeFetchEmojiImage = function makeFetchEmojiImage() {\n  return reflect(resolveImage);\n};\n/**\n * When an emoji as no color, it might still have 2 parts,\n * the canonical emoji and an empty string.\n * ex.\n *   (no color) Array.from('❤️') => [\"❤\", \"️\"]\n *   (w/ color) Array.from('👍🏿') => [\"👍\", \"🏿\"]\n *\n * The empty string needs to be removed otherwise the generated\n * url will be incorect.\n */\n\n\nvar _removeNoColor = function _removeNoColor(x) {\n  return x !== '️';\n};\n\nvar getCodePoints = function getCodePoints(string) {\n  return Array.from(string).filter(_removeNoColor).map(function (_char) {\n    return _char.codePointAt(0).toString(16);\n  }).join('-');\n};\n\nvar buildEmojiUrl = function buildEmojiUrl(emoji) {\n  var _Font$getEmojiSource = Font$1.getEmojiSource(),\n      url = _Font$getEmojiSource.url,\n      format = _Font$getEmojiSource.format;\n\n  return \"\" + url + getCodePoints(emoji) + \".\" + format;\n};\n\nvar fetchEmojis = function fetchEmojis(string) {\n  var emojiSource = Font$1.getEmojiSource();\n  if (!emojiSource || !emojiSource.url) return [];\n  var promises = [];\n  var match;\n\n  var _loop = function _loop() {\n    var emoji = match[0];\n\n    if (!emojis[emoji] || emojis[emoji].loading) {\n      var emojiUrl = buildEmojiUrl(emoji);\n      emojis[emoji] = {\n        loading: true\n      };\n      var fetchEmojiImage = makeFetchEmojiImage();\n      promises.push(fetchEmojiImage({\n        uri: emojiUrl\n      }).then(function (image) {\n        emojis[emoji].loading = false;\n        emojis[emoji].data = image.data;\n      }));\n    }\n  };\n\n  while (match = regex.exec(string)) {\n    _loop();\n  }\n\n  return promises;\n};\n\nvar embedEmojis = function embedEmojis(fragments) {\n  var result = [];\n\n  for (var i = 0; i < fragments.length; i++) {\n    var fragment = fragments[i];\n    var match = void 0;\n    var lastIndex = 0;\n\n    while (match = regex.exec(fragment.string)) {\n      var index = match.index;\n      var emoji = match[0];\n      var emojiSize = fragment.attributes.fontSize;\n      var chunk = fragment.string.slice(lastIndex, index + match[0].length); // If emoji image was found, we create a new fragment with the\n      // correct attachment and object substitution character;\n\n      if (emojis[emoji] && emojis[emoji].data) {\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0xfffc)),\n          attributes: _extends({}, fragment.attributes, {\n            attachment: {\n              width: emojiSize,\n              height: emojiSize,\n              yOffset: Math.floor(emojiSize * 0.1),\n              image: emojis[emoji].data\n            }\n          })\n        });\n      } else {\n        // If no emoji data, we just replace the emoji with a nodef char\n        result.push({\n          string: chunk.replace(match, String.fromCharCode(0)),\n          attributes: fragment.attributes\n        });\n      }\n\n      lastIndex = index + emoji.length;\n    }\n\n    if (lastIndex < fragment.string.length) {\n      result.push({\n        string: fragment.string.slice(lastIndex),\n        attributes: fragment.attributes\n      });\n    }\n  }\n\n  return result;\n};\n\nvar IGNORABLE_CODEPOINTS = [8232, // LINE_SEPARATOR\n8233 // PARAGRAPH_SEPARATOR\n];\n\nvar buildSubsetForFont = function buildSubsetForFont(font) {\n  return IGNORABLE_CODEPOINTS.reduce(function (acc, codePoint) {\n    if (font.hasGlyphForCodePoint && font.hasGlyphForCodePoint(codePoint)) {\n      return acc;\n    }\n\n    return [].concat(acc, [String.fromCharCode(codePoint)]);\n  }, []);\n};\n\nvar ignoreChars = function ignoreChars(fragments) {\n  return fragments.map(function (fragment) {\n    var charSubset = buildSubsetForFont(fragment.attributes.font);\n    var subsetRegex = new RegExp(charSubset.join('|'));\n    return {\n      string: fragment.string.replace(subsetRegex, ''),\n      attributes: fragment.attributes\n    };\n  });\n};\n\nvar PREPROCESSORS = [ignoreChars, embedEmojis];\n\nvar capitalize = function capitalize(value) {\n  return value.replace(/(^|\\s)\\S/g, function (l) {\n    return l.toUpperCase();\n  });\n};\n\nvar isImage = propEq('name', 'Image');\nvar isTextInstance = compose(complement(isNil), prop('value'));\n\nvar transformText = function transformText(text, transformation) {\n  switch (transformation) {\n    case 'uppercase':\n      return text.toUpperCase();\n\n    case 'lowercase':\n      return text.toLowerCase();\n\n    case 'capitalize':\n      return capitalize(text);\n\n    default:\n      return text;\n  }\n};\n\nvar getFragments = function getFragments(instance) {\n  if (!instance) return [{\n    string: ''\n  }];\n  var fragments = [];\n  var _instance$style = instance.style,\n      _instance$style$color = _instance$style.color,\n      color = _instance$style$color === void 0 ? 'black' : _instance$style$color,\n      backgroundColor = _instance$style.backgroundColor,\n      _instance$style$fontF = _instance$style.fontFamily,\n      fontFamily = _instance$style$fontF === void 0 ? 'Helvetica' : _instance$style$fontF,\n      fontWeight = _instance$style.fontWeight,\n      fontStyle = _instance$style.fontStyle,\n      _instance$style$fontS = _instance$style.fontSize,\n      fontSize = _instance$style$fontS === void 0 ? 18 : _instance$style$fontS,\n      _instance$style$textA = _instance$style.textAlign,\n      textAlign = _instance$style$textA === void 0 ? 'left' : _instance$style$textA,\n      lineHeight = _instance$style.lineHeight,\n      textDecoration = _instance$style.textDecoration,\n      textDecorationColor = _instance$style.textDecorationColor,\n      textDecorationStyle = _instance$style.textDecorationStyle,\n      textTransform = _instance$style.textTransform,\n      letterSpacing = _instance$style.letterSpacing,\n      textIndent = _instance$style.textIndent,\n      opacity = _instance$style.opacity;\n  var obj = Font$1.getFont({\n    fontFamily: fontFamily,\n    fontWeight: fontWeight,\n    fontStyle: fontStyle\n  });\n  var font = obj ? obj.data : fontFamily;\n  var attributes = {\n    font: font,\n    color: color,\n    opacity: opacity,\n    fontSize: fontSize,\n    backgroundColor: backgroundColor,\n    align: textAlign,\n    indent: textIndent,\n    link: instance.src,\n    characterSpacing: letterSpacing,\n    underlineStyle: textDecorationStyle,\n    underline: textDecoration === 'underline',\n    underlineColor: textDecorationColor || color,\n    strike: textDecoration === 'line-through',\n    strikeStyle: textDecorationStyle,\n    strikeColor: textDecorationColor || color,\n    lineHeight: lineHeight ? lineHeight * fontSize : null\n  };\n  instance.children.forEach(function (child) {\n    if (isImage(child)) {\n      fragments.push({\n        string: String.fromCharCode(0xfffc),\n        attributes: _extends({}, attributes, {\n          attachment: {\n            width: child.style.width || fontSize,\n            height: child.style.height || fontSize,\n            image: child.image.data\n          }\n        })\n      });\n    } else if (isTextInstance(child)) {\n      fragments.push({\n        string: transformText(child.value, textTransform),\n        attributes: attributes\n      });\n    } else {\n      if (child) {\n        var _fragments;\n\n        (_fragments = fragments).push.apply(_fragments, getFragments(child));\n      }\n    }\n  });\n\n  for (var _iterator = PREPROCESSORS, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();;) {\n    var _ref;\n\n    if (_isArray) {\n      if (_i >= _iterator.length) break;\n      _ref = _iterator[_i++];\n    } else {\n      _i = _iterator.next();\n      if (_i.done) break;\n      _ref = _i.value;\n    }\n\n    var preprocessor = _ref;\n    fragments = preprocessor(fragments);\n  }\n\n  return fragments;\n};\n\nvar getAttributedString = function getAttributedString(instance) {\n  return AttributedString.fromFragments(getFragments(instance));\n};\n\nvar Text =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Text, _Base);\n\n  function Text(root, props) {\n    var _this;\n\n    _this = _Base.call(this, root, props) || this;\n    _this.start = 0;\n    _this.end = 0;\n    _this.blocks = null;\n    _this.computed = false;\n    _this.attributedString = null;\n    _this.layoutOptions = {\n      hyphenationPenalty: props.hyphenationPenalty,\n      hyphenationCallback: Font$1.getHyphenationCallback(),\n      shrinkWhitespaceFactor: {\n        before: -0.5,\n        after: -0.5\n      }\n    };\n\n    _this.layout.setMeasureFunc(_this.measureText.bind(_assertThisInitialized(_this)));\n\n    return _this;\n  }\n\n  var _proto = Text.prototype;\n\n  _proto.appendChild = function appendChild(child) {\n    if (child) {\n      child.parent = this;\n      this.children.push(child);\n      this.computed = false;\n      this.attributedString = null;\n      this.markDirty();\n    }\n  };\n\n  _proto.removeChild = function removeChild(child) {\n    var index = this.children.indexOf(child);\n\n    if (index !== -1) {\n      child.parent = null;\n      this.children.splice(index, 1);\n      this.computed = false;\n      this.attributedString = null;\n      this.markDirty();\n      child.cleanup();\n    }\n  };\n\n  _proto.lineIndexAtHeight = function lineIndexAtHeight(height) {\n    var counter = 0;\n\n    for (var i = 0; i < this.lines.length; i++) {\n      var line = this.lines[i];\n      if (counter + line.box.height > height) return i;\n      counter += line.box.height;\n    }\n\n    return this.lines.length;\n  };\n\n  _proto.heightAtLineIndex = function heightAtLineIndex(index) {\n    var counter = 0;\n\n    for (var i = 0; i < index; i++) {\n      var line = this.lines[i];\n      counter += line.box.height;\n    }\n\n    return counter;\n  };\n\n  _proto.layoutText = function layoutText(width, height) {\n    this.attributedString = getAttributedString(this); // Text layout is expensive. That's why we ensure to only do it once\n    // (except dynamic nodes. Those change content and needs to relayout every time)\n\n    if (!this.blocks || this.props.render) {\n      // Do the actual text layout.\n      /// If height null or NaN, we take some liberty on layout height\n      var container = {\n        x: 0,\n        y: 0,\n        width: width,\n        height: height || Infinity,\n        maxLines: this.style.maxLines,\n        truncateMode: this.style.textOverflow\n      };\n      this.blocks = engine(this.attributedString, container, this.layoutOptions);\n    } // Get the total amount of rendered lines\n\n\n    var linesCount = this.blocks.reduce(function (acc, b) {\n      return acc + b.length;\n    }, 0);\n    this.end = linesCount + 1;\n    this.computed = true;\n  };\n\n  _proto.measureText = function measureText(width, widthMode, height, heightMode) {\n    if (widthMode === Yoga.MEASURE_MODE_EXACTLY) {\n      this.layoutText(width, height);\n      return {\n        height: this.linesHeight\n      };\n    }\n\n    if (widthMode === Yoga.MEASURE_MODE_AT_MOST) {\n      this.layoutText(width, height);\n      return {\n        height: this.linesHeight,\n        width: Math.min(width, this.linesWidth)\n      };\n    }\n\n    return {};\n  };\n\n  _proto.resolveStyles = function resolveStyles() {\n    var styles = _Base.prototype.resolveStyles.call(this); // Inherit relative positioning for inline childs\n\n\n    if (this.parent && this.parent.name === 'Text' && this.parent.style.position === 'relative') {\n      styles.top = styles.top || this.parent.style.top;\n      styles.bottom = styles.bottom || this.parent.style.bottom;\n      styles.position = styles.position || 'relative';\n    } // Apply default link styles\n\n\n    if (this.src) {\n      styles.color = styles.color || 'blue';\n      styles.textDecoration = styles.textDecoration || 'underline';\n    }\n\n    return styles;\n  };\n\n  _proto.wrapHeight = function wrapHeight(height) {\n    var _this$props = this.props,\n        orphans = _this$props.orphans,\n        widows = _this$props.widows;\n    var linesQuantity = this.lines.length;\n    var sliceHeight = height - this.paddingTop;\n    var slicedLine = this.lineIndexAtHeight(sliceHeight);\n\n    if (linesQuantity < orphans) {\n      return height;\n    } else if (slicedLine < orphans || linesQuantity < orphans + widows) {\n      return 0;\n    } else if (linesQuantity === orphans + widows) {\n      return this.heightAtLineIndex(orphans);\n    } else if (linesQuantity - slicedLine < widows) {\n      return height - this.heightAtLineIndex(widows - 1);\n    }\n\n    return height;\n  };\n\n  _proto.onNodeSplit = function onNodeSplit(height, clone) {\n    var wrapHeight = this.wrapHeight(height);\n    var slicedLineIndex = this.lineIndexAtHeight(wrapHeight);\n    clone.marginTop = 0;\n    clone.paddingTop = 0;\n    clone.start = slicedLineIndex;\n    clone.attributedString = this.attributedString;\n    this.height = wrapHeight;\n    this.marginBottom = 0;\n    this.paddingBottom = 0;\n    this.end = slicedLineIndex;\n  };\n\n  _proto.clone = function clone() {\n    var text = _Base.prototype.clone.call(this);\n\n    text.layoutEngine = this.layoutEngine; // Save calculated layout for non-dynamic clone elements\n\n    if (this.blocks && !this.props.render) {\n      text.blocks = [].concat(this.blocks);\n    }\n\n    return text;\n  };\n\n  _proto.renderText = function renderText() {\n    var _this$getAbsoluteLayo = this.getAbsoluteLayout(),\n        top = _this$getAbsoluteLayo.top,\n        left = _this$getAbsoluteLayo.left;\n\n    var initialY = this.lines[0] ? this.lines[0].box.y : 0; // We translate lines based on Yoga container\n\n    this.root.instance.save();\n    this.root.instance.translate(left + this.padding.left, top + this.padding.top - initialY); // Perform actual text rendering on document\n\n    PDFRenderer$1.render(this.root.instance, [this.lines]);\n    setLink(this);\n    setDestination(this);\n    this.root.instance.restore();\n  };\n\n  _proto.render =\n  /*#__PURE__*/\n  function () {\n    var _render = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              this.root.instance.save();\n              this.applyTransformations();\n              this.drawBackgroundColor();\n              this.drawBorders(); // Calculate text layout if needed\n              // This can happen if measureText was not called by Yoga\n\n              if (!this.computed) {\n                this.layoutText(this.width - this.padding.left - this.padding.right, this.height - this.padding.top - this.padding.bottom);\n              }\n\n              this.renderText();\n\n              if (this.props.debug) {\n                this.debug();\n              }\n\n              this.root.instance.restore();\n\n            case 8:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function render() {\n      return _render.apply(this, arguments);\n    }\n\n    return render;\n  }();\n\n  _createClass(Text, [{\n    key: \"name\",\n    get: function get() {\n      return 'Text';\n    }\n  }, {\n    key: \"src\",\n    get: function get() {\n      return getURL(this.props.src || this.props.href);\n    }\n  }, {\n    key: \"lines\",\n    get: function get() {\n      if (!this.blocks) return [];\n      return this.blocks.reduce(function (acc, block) {\n        return [].concat(acc, block);\n      }, []).splice(this.start, this.end);\n    }\n  }, {\n    key: \"linesHeight\",\n    get: function get() {\n      if (!this.blocks) return -1;\n      return this.lines.reduce(function (acc, line) {\n        return acc + line.box.height;\n      }, 0);\n    }\n  }, {\n    key: \"linesWidth\",\n    get: function get() {\n      if (!this.blocks) return -1;\n      return Math.max.apply(Math, this.lines.map(function (line) {\n        return AttributedString.advanceWidth(line);\n      }));\n    }\n  }]);\n\n  return Text;\n}(Base);\n\nText.defaultProps = {\n  wrap: true,\n  widows: 2,\n  orphans: 2\n};\n\nvar Link =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Link, _Base);\n\n  function Link() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Link.prototype;\n\n  _proto.render =\n  /*#__PURE__*/\n  function () {\n    var _render = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              setLink(this);\n              _context.next = 3;\n              return this.renderChildren();\n\n            case 3:\n              if (this.props.debug) this.debug();\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function render() {\n      return _render.apply(this, arguments);\n    }\n\n    return render;\n  }();\n\n  _createClass(Link, [{\n    key: \"name\",\n    get: function get() {\n      return 'Link';\n    }\n  }, {\n    key: \"src\",\n    get: function get() {\n      return getURL(this.props.src || this.props.href);\n    }\n  }]);\n\n  return Link;\n}(Base);\n\nvar Note =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Note, _Base);\n\n  function Note() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Note.prototype;\n\n  _proto.appendChild = function appendChild(child) {\n    if (child.name !== 'TextInstance') {\n      throw new Error('Note only accepts string children');\n    }\n\n    if (child) {\n      child.parent = this;\n      this.children.push(child);\n    }\n  };\n\n  _proto.removeChild = function removeChild(child) {\n    var index = this.children.indexOf(child);\n\n    if (index !== -1) {\n      child.parent = null;\n      this.children.splice(index, 1);\n    }\n\n    child.cleanup();\n  };\n\n  _proto.applyProps = function applyProps() {\n    _Base.prototype.applyProps.call(this);\n\n    this.height = 0;\n    this.width = 0;\n  };\n\n  _proto.render =\n  /*#__PURE__*/\n  function () {\n    var _render = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var _this$getAbsoluteLayo, top, left, value;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this$getAbsoluteLayo = this.getAbsoluteLayout(), top = _this$getAbsoluteLayo.top, left = _this$getAbsoluteLayo.left;\n              value = this.children[0] ? this.children[0].value : '';\n              this.root.instance.note(left, top, 0, 0, value);\n\n            case 3:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function render() {\n      return _render.apply(this, arguments);\n    }\n\n    return render;\n  }();\n\n  _createClass(Note, [{\n    key: \"name\",\n    get: function get() {\n      return 'Note';\n    }\n  }]);\n\n  return Note;\n}(Base);\n\nNote.defaultProps = {};\n\nvar isNumeric = function isNumeric(n) {\n  return !isNaN(parseFloat(n)) && isFinite(n);\n};\n\nvar applyContainObjectFit = function applyContainObjectFit(cw, ch, iw, ih, px, py) {\n  var cr = cw / ch;\n  var ir = iw / ih;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    var height = ch;\n    var width = height * ir;\n    var yOffset = isNumeric(py) ? py : 0;\n    var xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n    return {\n      width: width,\n      height: height,\n      xOffset: xOffset,\n      yOffset: yOffset\n    };\n  } else {\n    var _width = cw;\n\n    var _height = _width / ir;\n\n    var _xOffset = isNumeric(px) ? px : 0;\n\n    var _yOffset = isNumeric(py) ? py : (ch - _height) * pyv;\n\n    return {\n      width: _width,\n      height: _height,\n      yOffset: _yOffset,\n      xOffset: _xOffset\n    };\n  }\n};\n\nvar applyNoneObjectFit = function applyNoneObjectFit(cw, ch, iw, ih, px, py) {\n  var width = iw;\n  var height = ih;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n  var xOffset = isNumeric(px) ? px : (cw - width) * pxv;\n  var yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n  return {\n    width: width,\n    height: height,\n    xOffset: xOffset,\n    yOffset: yOffset\n  };\n};\n\nvar applyCoverObjectFit = function applyCoverObjectFit(cw, ch, iw, ih, px, py) {\n  var ir = iw / ih;\n  var cr = cw / ch;\n  var pxp = matchPercent(px);\n  var pyp = matchPercent(py);\n  var pxv = pxp ? pxp.percent : 0.5;\n  var pyv = pyp ? pyp.percent : 0.5;\n\n  if (cr > ir) {\n    var width = cw;\n    var height = width / ir;\n    var xOffset = isNumeric(px) ? px : 0;\n    var yOffset = isNumeric(py) ? py : (ch - height) * pyv;\n    return {\n      width: width,\n      height: height,\n      yOffset: yOffset,\n      xOffset: xOffset\n    };\n  } else {\n    var _height2 = ch;\n\n    var _width2 = _height2 * ir;\n\n    var _xOffset2 = isNumeric(px) ? px : (cw - _width2) * pxv;\n\n    var _yOffset2 = isNumeric(py) ? py : 0;\n\n    return {\n      width: _width2,\n      height: _height2,\n      xOffset: _xOffset2,\n      yOffset: _yOffset2\n    };\n  }\n};\n\nvar applyScaleDownObjectFit = function applyScaleDownObjectFit(cw, ch, iw, ih, px, py) {\n  var containDimension = applyContainObjectFit(cw, ch, iw, ih, px, py);\n  var noneDimension = applyNoneObjectFit(cw, ch, iw, ih, px, py);\n  return containDimension.width < noneDimension.width ? containDimension : noneDimension;\n};\n\nvar applyFillObjectFit = function applyFillObjectFit(cw, ch, px, py) {\n  return {\n    width: cw,\n    height: ch,\n    xOffset: matchPercent(px) ? 0 : px || 0,\n    yOffset: matchPercent(py) ? 0 : py || 0\n  };\n};\n\nvar resolveObjectFit = function resolveObjectFit(type, cw, ch, iw, ih, px, py) {\n  if (type === void 0) {\n    type = 'fill';\n  }\n\n  switch (type) {\n    case 'contain':\n      return applyContainObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'cover':\n      return applyCoverObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'none':\n      return applyNoneObjectFit(cw, ch, iw, ih, px, py);\n\n    case 'scale-down':\n      return applyScaleDownObjectFit(cw, ch, iw, ih, px, py);\n\n    default:\n      return applyFillObjectFit(cw, ch, px, py);\n  }\n};\n\nvar SAFETY_HEIGHT = 10;\n\nvar Image =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Image, _Base);\n\n  function Image(root, props) {\n    var _this;\n\n    _this = _Base.call(this, root, props) || this;\n    _this.image = null;\n\n    _this.layout.setMeasureFunc(_this.measureImage.bind(_assertThisInitialized(_this)));\n\n    return _this;\n  }\n\n  var _proto = Image.prototype;\n\n  _proto.shouldGrow = function shouldGrow() {\n    return !!this.style.flexGrow;\n  };\n\n  _proto.measureImage = function measureImage(width, widthMode, height, heightMode) {\n    var imageMargin = this.margin;\n    var pagePadding = this.page.padding;\n    var pageArea = this.page.isAutoHeight ? Infinity : this.page.size.height - pagePadding.top - pagePadding.bottom - imageMargin.top - imageMargin.bottom - SAFETY_HEIGHT; // Skip measure if image data not present yet\n\n    if (!this.image) return {\n      width: 0,\n      height: 0\n    };\n\n    if (widthMode === Yoga.MEASURE_MODE_EXACTLY && heightMode === Yoga.MEASURE_MODE_UNDEFINED) {\n      var scaledHeight = width / this.ratio;\n      return {\n        height: Math.min(pageArea, scaledHeight)\n      };\n    }\n\n    if (heightMode === Yoga.MEASURE_MODE_EXACTLY && (widthMode === Yoga.MEASURE_MODE_AT_MOST || widthMode === Yoga.MEASURE_MODE_UNDEFINED)) {\n      return {\n        width: Math.min(height * this.ratio, width)\n      };\n    }\n\n    if (widthMode === Yoga.MEASURE_MODE_EXACTLY && heightMode === Yoga.MEASURE_MODE_AT_MOST) {\n      var _scaledHeight = width / this.ratio;\n\n      return {\n        height: Math.min(height, pageArea, _scaledHeight)\n      };\n    }\n\n    if (widthMode === Yoga.MEASURE_MODE_AT_MOST && heightMode === Yoga.MEASURE_MODE_AT_MOST) {\n      if (this.ratio > 1) {\n        return {\n          width: width,\n          height: Math.min(width / this.ratio, height)\n        };\n      } else {\n        return {\n          width: Math.min(height * this.ratio, width),\n          height: height\n        };\n      }\n    }\n\n    return {\n      height: height,\n      width: width\n    };\n  };\n\n  _proto.fetch =\n  /*#__PURE__*/\n  function () {\n    var _fetch = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var _this$props, cache, safePath, allowDangerousPaths;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this$props = this.props, cache = _this$props.cache, safePath = _this$props.safePath, allowDangerousPaths = _this$props.allowDangerousPaths;\n\n              if (this.src) {\n                _context.next = 4;\n                break;\n              }\n\n              warning(false, 'Image should receive either a \"src\" or \"source\" prop');\n              return _context.abrupt(\"return\");\n\n            case 4:\n              _context.prev = 4;\n              _context.next = 7;\n              return resolveImage(this.src, {\n                cache: cache,\n                safePath: safePath,\n                allowDangerousPaths: allowDangerousPaths\n              });\n\n            case 7:\n              this.image = _context.sent;\n              _context.next = 14;\n              break;\n\n            case 10:\n              _context.prev = 10;\n              _context.t0 = _context[\"catch\"](4);\n              this.image = {\n                width: 0,\n                height: 0\n              };\n              console.warn(_context.t0.message);\n\n            case 14:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this, [[4, 10]]);\n    }));\n\n    function fetch() {\n      return _fetch.apply(this, arguments);\n    }\n\n    return fetch;\n  }();\n\n  _proto.clone = function clone() {\n    var clone = _Base.prototype.clone.call(this);\n\n    clone.image = this.image;\n    return clone;\n  };\n\n  _proto.onAppendDynamically =\n  /*#__PURE__*/\n  function () {\n    var _onAppendDynamically = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.fetch();\n\n            case 2:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function onAppendDynamically() {\n      return _onAppendDynamically.apply(this, arguments);\n    }\n\n    return onAppendDynamically;\n  }();\n\n  _proto.renderImage = function renderImage() {\n    var padding = this.padding;\n\n    var _this$getAbsoluteLayo = this.getAbsoluteLayout(),\n        left = _this$getAbsoluteLayo.left,\n        top = _this$getAbsoluteLayo.top;\n\n    var _this$style = this.style,\n        opacity = _this$style.opacity,\n        objectPositionX = _this$style.objectPositionX,\n        objectPositionY = _this$style.objectPositionY;\n    this.root.instance.save(); // Clip path to keep image inside border radius\n\n    this.clip();\n\n    if (this.image.data) {\n      var _resolveObjectFit = resolveObjectFit(this.style.objectFit, this.width - padding.left - padding.right, this.height - padding.top - padding.bottom, this.image.width, this.image.height, objectPositionX, objectPositionY),\n          width = _resolveObjectFit.width,\n          height = _resolveObjectFit.height,\n          xOffset = _resolveObjectFit.xOffset,\n          yOffset = _resolveObjectFit.yOffset;\n\n      if (width !== 0 && height !== 0) {\n        this.root.instance.fillOpacity(opacity).image(this.image.data, left + padding.left + xOffset, top + padding.top + yOffset, {\n          width: width,\n          height: height\n        });\n      } else {\n        warning(false, \"Image with src '\" + this.props.src + \"' skipped due to invalid dimensions\");\n      }\n    }\n\n    this.root.instance.restore();\n  };\n\n  _proto.render =\n  /*#__PURE__*/\n  function () {\n    var _render = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3() {\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              setDestination(this);\n              this.root.instance.save();\n              this.applyTransformations();\n              this.drawBackgroundColor();\n              this.renderImage();\n              this.drawBorders();\n\n              if (this.props.debug) {\n                this.debug();\n              }\n\n              this.root.instance.restore();\n\n            case 8:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    function render() {\n      return _render.apply(this, arguments);\n    }\n\n    return render;\n  }();\n\n  _createClass(Image, [{\n    key: \"name\",\n    get: function get() {\n      return 'Image';\n    }\n  }, {\n    key: \"ratio\",\n    get: function get() {\n      return this.image.data ? this.image.width / this.image.height : 1;\n    }\n  }, {\n    key: \"src\",\n    get: function get() {\n      var src = this.props.src || this.props.source;\n      return typeof src === 'string' ? {\n        uri: src\n      } : src;\n    }\n  }]);\n\n  return Image;\n}(Base);\n\nImage.defaultProps = {\n  wrap: false,\n  cache: true,\n  style: {}\n};\n\nvar Document =\n/*#__PURE__*/\nfunction () {\n  function Document(root, props) {\n    this.root = root;\n    this.style = {};\n    this.props = props;\n    this.children = [];\n    this.subpages = [];\n  }\n\n  var _proto = Document.prototype;\n\n  _proto.appendChild = function appendChild(child) {\n    child.parent = this;\n    this.children.push(child);\n  };\n\n  _proto.removeChild = function removeChild(child) {\n    var index = this.children.indexOf(child);\n\n    if (index !== -1) {\n      child.parent = null;\n      this.children.splice(index, 1);\n    }\n\n    child.cleanup();\n  };\n\n  _proto.addMetaData = function addMetaData() {\n    var _this$props = this.props,\n        title = _this$props.title,\n        author = _this$props.author,\n        subject = _this$props.subject,\n        keywords = _this$props.keywords,\n        creator = _this$props.creator,\n        producer = _this$props.producer; // The object keys need to start with a capital letter by the PDF spec\n\n    if (title) this.root.instance.info.Title = title;\n    if (author) this.root.instance.info.Author = author;\n    if (subject) this.root.instance.info.Subject = subject;\n    if (keywords) this.root.instance.info.Keywords = keywords;\n    this.root.instance.info.Creator = creator || 'react-pdf';\n    this.root.instance.info.Producer = producer || 'react-pdf';\n  };\n\n  _proto.loadFonts =\n  /*#__PURE__*/\n  function () {\n    var _loadFonts = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var promises, listToExplore, node;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              promises = [];\n              listToExplore = this.children.slice(0);\n\n              while (listToExplore.length > 0) {\n                node = listToExplore.shift();\n\n                if (node.style && node.style.fontFamily) {\n                  promises.push(Font$1.load(node.style, this.root.instance));\n                }\n\n                if (node.children) {\n                  node.children.forEach(function (childNode) {\n                    listToExplore.push(childNode);\n                  });\n                }\n              }\n\n              _context.next = 5;\n              return Promise.all(promises);\n\n            case 5:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function loadFonts() {\n      return _loadFonts.apply(this, arguments);\n    }\n\n    return loadFonts;\n  }();\n\n  _proto.loadEmojis =\n  /*#__PURE__*/\n  function () {\n    var _loadEmojis = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2() {\n      var promises, listToExplore, node;\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              promises = [];\n              listToExplore = this.children.slice(0);\n\n              while (listToExplore.length > 0) {\n                node = listToExplore.shift();\n\n                if (typeof node === 'string') {\n                  promises.push.apply(promises, fetchEmojis(node));\n                } else if (typeof node.value === 'string') {\n                  promises.push.apply(promises, fetchEmojis(node.value));\n                } else if (node.children) {\n                  node.children.forEach(function (childNode) {\n                    listToExplore.push(childNode);\n                  });\n                }\n              }\n\n              _context2.next = 5;\n              return Promise.all(promises);\n\n            case 5:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2, this);\n    }));\n\n    function loadEmojis() {\n      return _loadEmojis.apply(this, arguments);\n    }\n\n    return loadEmojis;\n  }();\n\n  _proto.loadImages =\n  /*#__PURE__*/\n  function () {\n    var _loadImages = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee3() {\n      var promises, listToExplore, node;\n      return _regeneratorRuntime.wrap(function _callee3$(_context3) {\n        while (1) {\n          switch (_context3.prev = _context3.next) {\n            case 0:\n              promises = [];\n              listToExplore = this.children.slice(0);\n\n              while (listToExplore.length > 0) {\n                node = listToExplore.shift();\n\n                if (node.name === 'Image') {\n                  promises.push(node.fetch());\n                }\n\n                if (node.children) {\n                  node.children.forEach(function (childNode) {\n                    listToExplore.push(childNode);\n                  });\n                }\n              }\n\n              _context3.next = 5;\n              return Promise.all(promises);\n\n            case 5:\n            case \"end\":\n              return _context3.stop();\n          }\n        }\n      }, _callee3, this);\n    }));\n\n    function loadImages() {\n      return _loadImages.apply(this, arguments);\n    }\n\n    return loadImages;\n  }();\n\n  _proto.loadAssets =\n  /*#__PURE__*/\n  function () {\n    var _loadAssets = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee4() {\n      return _regeneratorRuntime.wrap(function _callee4$(_context4) {\n        while (1) {\n          switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return Promise.all([this.loadFonts(), this.loadImages(), this.loadEmojis()]);\n\n            case 2:\n            case \"end\":\n              return _context4.stop();\n          }\n        }\n      }, _callee4, this);\n    }));\n\n    function loadAssets() {\n      return _loadAssets.apply(this, arguments);\n    }\n\n    return loadAssets;\n  }();\n\n  _proto.applyProps = function applyProps() {\n    this.children.forEach(function (child) {\n      return child.applyProps();\n    });\n  };\n\n  _proto.update = function update(newProps) {\n    this.props = newProps;\n  };\n\n  _proto.cleanup = function cleanup() {\n    this.subpages.forEach(function (p) {\n      return p.cleanup();\n    });\n  };\n\n  _proto.finish = function finish() {\n    this.children.forEach(function (c) {\n      return c.cleanup();\n    });\n  };\n\n  _proto.getLayoutData = function getLayoutData() {\n    return {\n      type: this.name,\n      children: this.subpages.map(function (c) {\n        return c.getLayoutData();\n      })\n    };\n  };\n\n  _proto.wrapPages =\n  /*#__PURE__*/\n  function () {\n    var _wrapPages2 = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee5() {\n      var pageCount, pages, _iterator, _isArray, _i, _ref, page, wrapArea, subpages;\n\n      return _regeneratorRuntime.wrap(function _callee5$(_context5) {\n        while (1) {\n          switch (_context5.prev = _context5.next) {\n            case 0:\n              pageCount = 1;\n              pages = [];\n              _iterator = this.children, _isArray = Array.isArray(_iterator), _i = 0, _iterator = _isArray ? _iterator : _iterator[Symbol.iterator]();\n\n            case 3:\n              if (!_isArray) {\n                _context5.next = 9;\n                break;\n              }\n\n              if (!(_i >= _iterator.length)) {\n                _context5.next = 6;\n                break;\n              }\n\n              return _context5.abrupt(\"break\", 26);\n\n            case 6:\n              _ref = _iterator[_i++];\n              _context5.next = 13;\n              break;\n\n            case 9:\n              _i = _iterator.next();\n\n              if (!_i.done) {\n                _context5.next = 12;\n                break;\n              }\n\n              return _context5.abrupt(\"break\", 26);\n\n            case 12:\n              _ref = _i.value;\n\n            case 13:\n              page = _ref;\n\n              if (!page.wrap) {\n                _context5.next = 23;\n                break;\n              }\n\n              wrapArea = page.isAutoHeight ? Infinity : page.size.height - (page.style.paddingBottom || 0);\n              _context5.next = 18;\n              return _wrapPages(page, wrapArea, pageCount);\n\n            case 18:\n              subpages = _context5.sent;\n              pageCount += subpages.length;\n              pages.push.apply(pages, subpages);\n              _context5.next = 24;\n              break;\n\n            case 23:\n              pages.push(page);\n\n            case 24:\n              _context5.next = 3;\n              break;\n\n            case 26:\n              return _context5.abrupt(\"return\", pages);\n\n            case 27:\n            case \"end\":\n              return _context5.stop();\n          }\n        }\n      }, _callee5, this);\n    }));\n\n    function wrapPages() {\n      return _wrapPages2.apply(this, arguments);\n    }\n\n    return wrapPages;\n  }();\n\n  _proto.renderPages =\n  /*#__PURE__*/\n  function () {\n    var _renderPages = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee6() {\n      var j;\n      return _regeneratorRuntime.wrap(function _callee6$(_context6) {\n        while (1) {\n          switch (_context6.prev = _context6.next) {\n            case 0:\n              _context6.next = 2;\n              return this.wrapPages();\n\n            case 2:\n              this.subpages = _context6.sent;\n              j = 0;\n\n            case 4:\n              if (!(j < this.subpages.length)) {\n                _context6.next = 11;\n                break;\n              } // Update dynamic text nodes with total pages info\n\n\n              this.subpages[j].renderDynamicNodes({\n                pageNumber: j + 1,\n                totalPages: this.subpages.length\n              }, function (node) {\n                return node.name === 'Text';\n              });\n              _context6.next = 8;\n              return this.subpages[j].render();\n\n            case 8:\n              j++;\n              _context6.next = 4;\n              break;\n\n            case 11:\n              return _context6.abrupt(\"return\", this.subpages);\n\n            case 12:\n            case \"end\":\n              return _context6.stop();\n          }\n        }\n      }, _callee6, this);\n    }));\n\n    function renderPages() {\n      return _renderPages.apply(this, arguments);\n    }\n\n    return renderPages;\n  }();\n\n  _proto.render =\n  /*#__PURE__*/\n  function () {\n    var _render = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee7() {\n      return _regeneratorRuntime.wrap(function _callee7$(_context7) {\n        while (1) {\n          switch (_context7.prev = _context7.next) {\n            case 0:\n              _context7.prev = 0;\n              this.addMetaData();\n              this.applyProps();\n              _context7.next = 5;\n              return this.loadAssets();\n\n            case 5:\n              _context7.next = 7;\n              return this.renderPages();\n\n            case 7:\n              this.root.instance.end();\n              Font$1.reset();\n              _context7.next = 14;\n              break;\n\n            case 11:\n              _context7.prev = 11;\n              _context7.t0 = _context7[\"catch\"](0);\n              throw _context7.t0;\n\n            case 14:\n            case \"end\":\n              return _context7.stop();\n          }\n        }\n      }, _callee7, this, [[0, 11]]);\n    }));\n\n    function render() {\n      return _render.apply(this, arguments);\n    }\n\n    return render;\n  }();\n\n  _createClass(Document, [{\n    key: \"name\",\n    get: function get() {\n      return 'Document';\n    }\n  }]);\n\n  return Document;\n}();\n\nDocument.defaultProps = {\n  author: null,\n  keywords: null,\n  subject: null,\n  title: null\n};\nvar availableMethods = ['dash', 'clip', 'save', 'path', 'fill', 'font', 'text', 'rect', 'scale', 'moveTo', 'lineTo', 'stroke', 'rotate', 'circle', 'lineCap', 'opacity', 'ellipse', 'polygon', 'restore', 'lineJoin', 'fontSize', 'fillColor', 'lineWidth', 'translate', 'miterLimit', 'strokeColor', 'fillOpacity', 'roundedRect', 'strokeOpacity', 'bezierCurveTo', 'quadraticCurveTo', 'linearGradient', 'radialGradient'];\n\nvar painter = function painter(instance) {\n  var p = availableMethods.reduce(function (acc, prop) {\n    var _extends2;\n\n    return _extends({}, acc, (_extends2 = {}, _extends2[prop] = function () {\n      instance[prop].apply(instance, arguments);\n      return p;\n    }, _extends2));\n  }, {});\n  return p;\n};\n\nvar Canvas =\n/*#__PURE__*/\nfunction (_Base) {\n  _inheritsLoose(Canvas, _Base);\n\n  function Canvas() {\n    return _Base.apply(this, arguments) || this;\n  }\n\n  var _proto = Canvas.prototype;\n\n  _proto.render =\n  /*#__PURE__*/\n  function () {\n    var _render = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var _this$getAbsoluteLayo, left, top, width, height, availableWidth, availableHeight;\n\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _this$getAbsoluteLayo = this.getAbsoluteLayout(), left = _this$getAbsoluteLayo.left, top = _this$getAbsoluteLayo.top, width = _this$getAbsoluteLayo.width, height = _this$getAbsoluteLayo.height;\n              availableWidth = width - this.paddingLeft - this.paddingRight;\n              availableHeight = height - this.paddingTop - this.paddingBottom;\n              warning(availableWidth && availableHeight, 'Canvas element has null width or height. Please provide valid values via the `style` prop in order to correctly render it.');\n              this.root.instance.save();\n              this.applyTransformations();\n              this.drawBackgroundColor();\n              this.drawBorders();\n              this.clip();\n              this.root.instance.translate(left + this.paddingLeft, top + this.paddingTop);\n\n              if (this.props.paint) {\n                this.props.paint(painter(this.root.instance), availableWidth, availableHeight);\n              }\n\n              this.root.instance.restore();\n\n              if (this.props.debug) {\n                this.debug();\n              }\n\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee, this);\n    }));\n\n    function render() {\n      return _render.apply(this, arguments);\n    }\n\n    return render;\n  }();\n\n  _createClass(Canvas, [{\n    key: \"name\",\n    get: function get() {\n      return 'Canvas';\n    }\n  }]);\n\n  return Canvas;\n}(Base);\n\nCanvas.defaultProps = {\n  style: {},\n  wrap: false\n};\nvar constructors = {\n  ROOT: Root,\n  PAGE: Page,\n  TEXT: Text,\n  LINK: Link,\n  VIEW: View,\n  NOTE: Note,\n  IMAGE: Image,\n  CANVAS: Canvas,\n  DOCUMENT: Document,\n  TEXT_INSTANCE: TextInstance\n};\n\nfunction createInstance(element, root) {\n  var type = element.type,\n      _element$props = element.props,\n      props = _element$props === void 0 ? {} : _element$props;\n\n  if (constructors[type]) {\n    return new constructors[type](root, props);\n  }\n\n  throw new Error(\"Invalid element of type \" + type + \" passed to PDF renderer\");\n}\n\nvar propsEqual = function propsEqual(a, b) {\n  var oldPropsKeys = Object.keys(a);\n  var newPropsKeys = Object.keys(b);\n\n  if (oldPropsKeys.length !== newPropsKeys.length) {\n    return false;\n  }\n\n  for (var i = 0; i < oldPropsKeys.length; i++) {\n    var propName = oldPropsKeys[i];\n\n    if (propName === 'render') {\n      if (!a[propName] !== !b[propName]) {\n        return false;\n      }\n\n      continue;\n    }\n\n    if (propName !== 'children' && a[propName] !== b[propName]) {\n      if (typeof a[propName] === 'object' && typeof b[propName] === 'object' && propsEqual(a[propName], b[propName])) {\n        continue;\n      }\n\n      return false;\n    }\n\n    if (propName === 'children' && (typeof a[propName] === 'string' || typeof b[propName] === 'string')) {\n      return a[propName] === b[propName];\n    }\n  }\n\n  return true;\n};\n\nvar emptyObject = {}; // If the Link has a strign child or render prop, substitute the instance by a Text,\n// that will ultimately render the inline Link via the textkit PDF renderer.\n\nvar shouldReplaceLink = function shouldReplaceLink(type, props) {\n  return type === 'LINK' && (typeof props.children === 'string' || typeof props.children === 'number' || Array.isArray(props.children) || props.render);\n};\n\nvar PDFRenderer = ReactFiberReconciler({\n  schedulePassiveEffects: unstable_scheduleCallback,\n  cancelPassiveEffects: unstable_cancelCallback,\n  supportsMutation: true,\n  appendInitialChild: function appendInitialChild(parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  createInstance: function createInstance$1(type, props, internalInstanceHandle) {\n    var instanceType = shouldReplaceLink(type, props) ? 'TEXT' : type;\n    return createInstance({\n      type: instanceType,\n      props: props\n    }, internalInstanceHandle);\n  },\n  createTextInstance: function createTextInstance(text, rootContainerInstance) {\n    return createInstance({\n      type: 'TEXT_INSTANCE',\n      props: text\n    }, rootContainerInstance);\n  },\n  finalizeInitialChildren: function finalizeInitialChildren(element, type, props) {\n    return false;\n  },\n  getPublicInstance: function getPublicInstance(instance) {\n    return instance;\n  },\n  prepareForCommit: function prepareForCommit() {// Noop\n  },\n  prepareUpdate: function prepareUpdate(element, type, oldProps, newProps) {\n    return !propsEqual(oldProps, newProps);\n  },\n  resetAfterCommit: function resetAfterCommit() {// Noop\n  },\n  resetTextContent: function resetTextContent(element) {// Noop\n  },\n  getRootHostContext: function getRootHostContext() {\n    return emptyObject;\n  },\n  getChildHostContext: function getChildHostContext() {\n    return emptyObject;\n  },\n  shouldSetTextContent: function shouldSetTextContent(type, props) {\n    return false;\n  },\n  now: Date.now,\n  useSyncScheduling: true,\n  appendChild: function appendChild(parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  appendChildToContainer: function appendChildToContainer(parentInstance, child) {\n    parentInstance.appendChild(child);\n  },\n  insertBefore: function insertBefore(parentInstance, child, beforeChild) {\n    parentInstance.appendChildBefore(child, beforeChild);\n  },\n  removeChild: function removeChild(parentInstance, child) {\n    parentInstance.removeChild(child);\n  },\n  removeChildFromContainer: function removeChildFromContainer(parentInstance, child) {\n    parentInstance.removeChild(child);\n  },\n  commitTextUpdate: function commitTextUpdate(textInstance, oldText, newText) {\n    textInstance.update(newText);\n  },\n  commitUpdate: function commitUpdate(instance, updatePayload, type, oldProps, newProps) {\n    instance.update(newProps);\n  }\n});\nvar version = \"1.6.8\";\nvar View$1 = 'VIEW';\nvar Text$1 = 'TEXT';\nvar Link$1 = 'LINK';\nvar Page$1 = 'PAGE';\nvar Note$1 = 'NOTE';\nvar Image$1 = 'IMAGE';\nvar Document$1 = 'DOCUMENT';\nvar Canvas$1 = 'CANVAS';\n\nvar pdf = function pdf(input) {\n  var container = createInstance({\n    type: 'ROOT'\n  });\n  var mountNode = PDFRenderer.createContainer(container);\n  if (input) updateContainer(input);\n\n  function callOnRender(params) {\n    if (params === void 0) {\n      params = {};\n    }\n\n    if (container.document.props.onRender) {\n      var layoutData = container.document.getLayoutData();\n      container.document.props.onRender(_extends({}, params, {\n        layoutData: layoutData\n      }));\n    }\n  }\n\n  function isDirty() {\n    return container.isDirty;\n  }\n\n  function updateContainer(doc) {\n    PDFRenderer.updateContainer(doc, mountNode, null);\n  }\n\n  function toBlob() {\n    return _toBlob.apply(this, arguments);\n  }\n\n  function _toBlob() {\n    _toBlob = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee() {\n      var stream;\n      return _regeneratorRuntime.wrap(function _callee$(_context) {\n        while (1) {\n          switch (_context.prev = _context.next) {\n            case 0:\n              _context.next = 2;\n              return container.render();\n\n            case 2:\n              stream = container.instance.pipe(BlobStream());\n              return _context.abrupt(\"return\", new Promise(function (resolve, reject) {\n                stream.on('finish', function () {\n                  try {\n                    var blob = stream.toBlob('application/pdf');\n                    callOnRender({\n                      blob: blob\n                    });\n                    resolve(blob);\n                  } catch (error) {\n                    reject(error);\n                  }\n                });\n                stream.on('error', reject);\n              }));\n\n            case 4:\n            case \"end\":\n              return _context.stop();\n          }\n        }\n      }, _callee);\n    }));\n    return _toBlob.apply(this, arguments);\n  }\n\n  function toBuffer() {\n    return _toBuffer.apply(this, arguments);\n  }\n\n  function _toBuffer() {\n    _toBuffer = _asyncToGenerator(\n    /*#__PURE__*/\n    _regeneratorRuntime.mark(function _callee2() {\n      return _regeneratorRuntime.wrap(function _callee2$(_context2) {\n        while (1) {\n          switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return container.render();\n\n            case 2:\n              callOnRender();\n              return _context2.abrupt(\"return\", container.instance);\n\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }\n      }, _callee2);\n    }));\n    return _toBuffer.apply(this, arguments);\n  }\n\n  function toString() {\n    var result = '';\n    container.render();\n    return new Promise(function (resolve, reject) {\n      try {\n        container.instance.on('data', function (buffer) {\n          result += buffer;\n        });\n        container.instance.on('end', function () {\n          callOnRender({\n            string: result\n          });\n          resolve(result);\n        });\n      } catch (error) {\n        reject(error);\n      }\n    });\n  }\n\n  return {\n    isDirty: isDirty,\n    container: container,\n    updateContainer: updateContainer,\n    toBuffer: toBuffer,\n    toBlob: toBlob,\n    toString: toString\n  };\n};\n\nvar flatStyles = function flatStyles(stylesArray) {\n  return stylesArray.reduce(function (acc, style) {\n    return _extends({}, acc, {}, style);\n  }, {});\n};\n\nvar Document$2 = function Document(_ref) {\n  var children = _ref.children,\n      props = _objectWithoutPropertiesLoose(_ref, [\"children\"]);\n\n  return React.createElement(Document$1, props, children);\n};\n\nvar InternalBlobProvider =\n/*#__PURE__*/\nfunction (_React$PureComponent) {\n  _inheritsLoose(InternalBlobProvider, _React$PureComponent);\n\n  function InternalBlobProvider(props) {\n    var _this;\n\n    _this = _React$PureComponent.call(this, props) || this; // Create new root container for this render\n\n    _this.state = {\n      blob: null,\n      url: null,\n      loading: true,\n      error: null\n    };\n    _this.instance = pdf();\n    return _this;\n  }\n\n  var _proto = InternalBlobProvider.prototype;\n\n  _proto.componentDidMount = function componentDidMount() {\n    this.renderDocument();\n    this.onDocumentUpdate();\n  };\n\n  _proto.componentDidUpdate = function componentDidUpdate() {\n    this.renderDocument();\n\n    if (this.instance.isDirty() && !this.state.error) {\n      this.onDocumentUpdate();\n    }\n  };\n\n  _proto.renderDocument = function renderDocument() {\n    this.instance.updateContainer(this.props.document);\n  };\n\n  _proto.onDocumentUpdate = function onDocumentUpdate() {\n    var _this2 = this;\n\n    var oldBlobUrl = this.state.url;\n    this.instance.toBlob().then(function (blob) {\n      _this2.setState({\n        blob: blob,\n        url: URL.createObjectURL(blob),\n        loading: false\n      }, function () {\n        return URL.revokeObjectURL(oldBlobUrl);\n      });\n    })[\"catch\"](function (error) {\n      _this2.setState({\n        error: error\n      });\n\n      console.error(error);\n      throw error;\n    });\n  };\n\n  _proto.render = function render() {\n    return this.props.children(this.state);\n  };\n\n  return InternalBlobProvider;\n}(React.PureComponent);\n\nvar BlobProvider = function BlobProvider(_ref2) {\n  var doc = _ref2.document,\n      children = _ref2.children;\n\n  if (!doc) {\n    warning(false, 'You should pass a valid document to BlobProvider');\n    return null;\n  }\n\n  return React.createElement(InternalBlobProvider, {\n    document: doc\n  }, children);\n};\n\nvar PDFViewer = function PDFViewer(_ref3) {\n  var className = _ref3.className,\n      style = _ref3.style,\n      children = _ref3.children,\n      innerRef = _ref3.innerRef,\n      props = _objectWithoutPropertiesLoose(_ref3, [\"className\", \"style\", \"children\", \"innerRef\"]);\n\n  return React.createElement(InternalBlobProvider, {\n    document: children\n  }, function (_ref4) {\n    var url = _ref4.url;\n    return React.createElement(\"iframe\", _extends({\n      className: className,\n      ref: innerRef,\n      src: url,\n      style: Array.isArray(style) ? flatStyles(style) : style\n    }, props));\n  });\n};\n\nvar PDFDownloadLink = function PDFDownloadLink(_ref5) {\n  var doc = _ref5.document,\n      className = _ref5.className,\n      style = _ref5.style,\n      children = _ref5.children,\n      _ref5$fileName = _ref5.fileName,\n      fileName = _ref5$fileName === void 0 ? 'document.pdf' : _ref5$fileName;\n\n  if (!doc) {\n    warning(false, 'You should pass a valid document to PDFDownloadLink');\n    return null;\n  }\n\n  var downloadOnIE = function downloadOnIE(blob) {\n    return function () {\n      if (window.navigator.msSaveBlob) {\n        window.navigator.msSaveBlob(blob, fileName);\n      }\n    };\n  };\n\n  return React.createElement(InternalBlobProvider, {\n    document: doc\n  }, function (params) {\n    return React.createElement(\"a\", {\n      className: className,\n      download: fileName,\n      href: params.url,\n      onClick: downloadOnIE(params.blob),\n      style: Array.isArray(style) ? flatStyles(style) : style\n    }, typeof children === 'function' ? children(params) : children);\n  });\n};\n\nvar dom = {\n  pdf: pdf,\n  View: View$1,\n  Text: Text$1,\n  Link: Link$1,\n  Page: Page$1,\n  Font: Font$1,\n  Note: Note$1,\n  Image: Image$1,\n  Canvas: Canvas$1,\n  version: version,\n  Document: Document$2,\n  PDFViewer: PDFViewer,\n  StyleSheet: StyleSheet,\n  PDFRenderer: PDFRenderer,\n  BlobProvider: BlobProvider,\n  createInstance: createInstance,\n  PDFDownloadLink: PDFDownloadLink\n};\nexport default dom;\nexport { BlobProvider, Canvas$1 as Canvas, Document$2 as Document, Font$1 as Font, Image$1 as Image, Link$1 as Link, Note$1 as Note, PDFDownloadLink, PDFRenderer, PDFViewer, Page$1 as Page, StyleSheet, Text$1 as Text, View$1 as View, createInstance, pdf, version };","map":null,"metadata":{},"sourceType":"module"}