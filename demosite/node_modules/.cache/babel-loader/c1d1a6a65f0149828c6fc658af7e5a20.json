{"ast":null,"code":"/** Franklin M. Liang's hyphenation algorithm, implemented in Javascript.\n *  Copyright (C) 2016 Yevhen Tiurin (yevhentiurin@gmail.com)\n *  https://github.com/ytiurin/hyphen\n *\n *  Released under the MIT license\n *  https://github.com/ytiurin/hyphen/blob/master/LICENSE\n */\n(function (root, factory) {\n  if (typeof define === \"function\" && define.amd) {\n    // AMD. Register as an anonymous module.\n    define([], factory);\n  } else if (typeof module === \"object\" && module.exports) {\n    // Node. Does not work with strict CommonJS, but\n    // only CommonJS-like environments that support module.exports,\n    // like Node.\n    module.exports = factory();\n  } else {\n    // Browser globals (root is window)\n    root.createHyphenator = factory();\n  }\n})(this, function () {\n  var // settings\n  SETTING_DEBUG = false,\n      SETTING_HYPHEN_CHAR = \"\\u00AD\";\n\n  function hyphenateWord(text, patterns, debug, hyphenChar) {\n    var pattern,\n        patternData,\n        patternIndex = 0;\n    var p = [];\n    var levels = new Array(text.length + 1);\n\n    for (var i = levels.length; i--;) levels[i] = 0;\n\n    while (patternData = patterns[patternIndex++]) {\n      var patternEntityIndex = text.toLocaleLowerCase().indexOf(patternData.text);\n      var patternFits = patternEntityIndex > -1 && (patternData.stickToLeft ? patternEntityIndex === 0 : true) && (patternData.stickToRight ? patternEntityIndex + patternData.text.length === text.length : true);\n\n      if (patternFits) {\n        p.push(patternData.pattern + \">\" + patternData.levels.join(\"\"));\n\n        for (var i = 0; i < patternData.levels.length; i++) levels[patternEntityIndex + i] = Math.max(patternData.levels[i], levels[patternEntityIndex + i]);\n      }\n    }\n\n    levels[0] = levels[1] = levels[levels.length - 1] = levels[levels.length - 2] = 0;\n    var hyphenatedText = \"\",\n        leveledText = \"\",\n        debugHyphenatedText = \"\";\n\n    for (var i = 0; i < levels.length; i++) {\n      hyphenatedText += (levels[i] % 2 === 1 ? hyphenChar : \"\") + text.charAt(i);\n      debugHyphenatedText += (levels[i] % 2 === 1 ? \"-\" : \"\") + text.charAt(i);\n      leveledText += (levels[i] > 0 ? levels[i] : \"\") + text.charAt(i);\n    }\n\n    if (debug) console.log.apply(console, [text, \"->\"].concat(p).concat([\"->\"]).concat(levels).concat([\"->\", leveledText]).concat([\"->\", debugHyphenatedText]));\n    return hyphenatedText;\n  }\n\n  function iterateSourceText(text) {\n    var nextCharIndex = 0;\n    var states = {\n      readWord: 1,\n      returnWord: 2,\n      returnChar: 3\n    };\n    return {\n      next: function () {\n        var nextChar,\n            nextWord = \"\";\n\n        while (nextChar = text.charAt(nextCharIndex++)) {\n          var charIsSpaceOrSpecial = /\\s|[\\!-\\@\\[-\\`\\{-\\xbf]/.test(nextChar);\n          var state = !charIsSpaceOrSpecial ? states.readWord : state === states.readWord ? states.returnWord : states.returnChar;\n\n          switch (state) {\n            case states.readWord:\n              nextWord += nextChar;\n              break;\n\n            case states.returnWord:\n              nextCharIndex--;\n              return nextWord;\n\n            case states.returnChar:\n              return nextChar;\n          }\n        }\n\n        if (nextWord !== \"\") {\n          return nextWord;\n        }\n      }\n    };\n  }\n\n  function start(text, patterns, cache, debug, hyphenChar) {\n    var newText = \"\",\n        nextWord,\n        readWord = iterateSourceText(text),\n        states = {\n      hyphenateWord: 1,\n      concatenate: 2\n    },\n        processedN = 0,\n        hyphenatedN = 0;\n\n    while (nextWord = readWord.next()) {\n      var state = nextWord.length > 4 ? states.hyphenateWord : states.concatenate;\n\n      switch (state) {\n        case states.hyphenateWord:\n          if (!cache[nextWord]) cache[nextWord] = hyphenateWord(nextWord, patterns, debug, hyphenChar);\n          if (nextWord !== cache[nextWord]) hyphenatedN++;\n          nextWord = cache[nextWord];\n\n        case states.concatenate:\n          newText += nextWord;\n      }\n\n      processedN++;\n    }\n\n    if (debug) console.log(\"----------------\\nHyphenation stats: \" + processedN + \" words processed, \" + hyphenatedN + \" words hyphenated\");\n    return newText;\n  } // extract useful data from pattern\n\n\n  function preprocessPattern(pattern) {\n    var patternCharIndex = 0,\n        patternChar,\n        patternData = {\n      pattern: pattern,\n      text: \"\",\n      levels: [],\n      stickToLeft: 0,\n      stickToRight: 0\n    },\n        states = {\n      alphabet: 1,\n      level: 2,\n      stickToLeft: 3,\n      stickToRight: 4\n    };\n\n    while (patternChar = pattern.charAt(patternCharIndex++)) {\n      var charIsDot = patternChar === \".\",\n          charIsNumber = !charIsDot && /\\d/.test(patternChar),\n          state = charIsDot ? patternCharIndex - 1 === 0 ? states.stickToLeft : states.stickToRight : charIsNumber ? states.level : states.alphabet;\n\n      switch (state) {\n        case states.alphabet:\n          !prevCharIsNumber && patternData.levels.push(0);\n          patternData.text += patternChar;\n          break;\n\n        case states.level:\n          patternData.levels.push(parseInt(patternChar));\n          break;\n\n        case states.stickToLeft:\n          patternData.stickToLeft = true;\n          break;\n\n        case states.stickToRight:\n          patternData.stickToRight = true;\n          break;\n      }\n\n      var prevCharIsNumber = charIsNumber;\n    }\n\n    return patternData;\n  }\n\n  function purifyPatterns(text) {\n    return text // Remove comments\n    .replace(/%.*/g, \"\") // Remove repeating spaces\n    .replace(/\\s+/g, \" \") // Trim spaces\n    .replace(/^\\s|\\s$/g, \"\") // Split to Array\n    .split(\" \");\n  } // Hyphenator factory\n\n\n  return function (patternsDefinition, settings) {\n    var // Settings\n    debug = settings && settings.debug !== undefined && settings.debug || SETTING_DEBUG,\n        hyphenChar = settings && settings.hyphenChar !== undefined && settings.hyphenChar || SETTING_HYPHEN_CHAR,\n        cache = {},\n        // Preprocess patterns\n    patterns = (patternsDefinition.patterns.splice ? patternsDefinition.patterns : purifyPatterns(patternsDefinition.patterns)).map(function (pattern) {\n      return preprocessPattern(pattern);\n    }); // Prepare cache\n\n    (patternsDefinition.exceptions.splice ? patternsDefinition.exceptions : purifyPatterns(patternsDefinition.exceptions)).forEach(function (exception) {\n      cache[exception.replace(/\\-/g, \"\")] = exception.replace(/\\-/g, hyphenChar);\n    }); // Hyphenator function\n\n    return function (text) {\n      return start(text, patterns, cache, debug, hyphenChar);\n    };\n  };\n});","map":null,"metadata":{},"sourceType":"script"}