{"ast":null,"code":"import { Component as e, useRef as t, useEffect as n } from \"react\";\nimport o from \"prop-types\";\n\nfunction r(e) {\n  return (r = \"function\" == typeof Symbol && \"symbol\" == typeof Symbol.iterator ? function (e) {\n    return typeof e;\n  } : function (e) {\n    return e && \"function\" == typeof Symbol && e.constructor === Symbol && e !== Symbol.prototype ? \"symbol\" : typeof e;\n  })(e);\n}\n\nfunction i(e, t) {\n  for (var n = 0; n < t.length; n++) {\n    var o = t[n];\n    o.enumerable = o.enumerable || !1, o.configurable = !0, \"value\" in o && (o.writable = !0), Object.defineProperty(e, o.key, o);\n  }\n}\n\nfunction u(e) {\n  return (u = Object.setPrototypeOf ? Object.getPrototypeOf : function (e) {\n    return e.__proto__ || Object.getPrototypeOf(e);\n  })(e);\n}\n\nfunction c(e, t) {\n  return (c = Object.setPrototypeOf || function (e, t) {\n    return e.__proto__ = t, e;\n  })(e, t);\n}\n\nfunction s(e) {\n  if (void 0 === e) throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  return e;\n}\n\nfunction a(e, t) {\n  return !t || \"object\" != typeof t && \"function\" != typeof t ? s(e) : t;\n}\n\nfunction l(e) {\n  var t = function () {\n    if (\"undefined\" == typeof Reflect || !Reflect.construct) return !1;\n    if (Reflect.construct.sham) return !1;\n    if (\"function\" == typeof Proxy) return !0;\n\n    try {\n      return Date.prototype.toString.call(Reflect.construct(Date, [], function () {})), !0;\n    } catch (e) {\n      return !1;\n    }\n  }();\n\n  return function () {\n    var n,\n        o = u(e);\n\n    if (t) {\n      var r = u(this).constructor;\n      n = Reflect.construct(o, arguments, r);\n    } else n = o.apply(this, arguments);\n\n    return a(this, n);\n  };\n}\n\nvar d = \"object\" === (\"undefined\" == typeof window || \"undefined\" == typeof window ? \"undefined\" : r(window)),\n    f = d ? document : {},\n    v = [\"mousemove\", \"keydown\", \"wheel\", \"DOMMouseScroll\", \"mousewheel\", \"mousedown\", \"touchstart\", \"touchmove\", \"MSPointerDown\", \"MSPointerMove\", \"visibilitychange\"];\n\nfunction p(e, t) {\n  var n;\n  return function () {\n    for (var o = arguments.length, r = new Array(o), i = 0; i < o; i++) r[i] = arguments[i];\n\n    n && clearTimeout(n), n = setTimeout(function () {\n      e.apply(void 0, r), n = null;\n    }, t);\n  };\n}\n\nfunction h(e, t) {\n  var n = 0;\n  return function () {\n    var o = new Date().getTime();\n    if (!(o - n < t)) return n = o, e.apply(void 0, arguments);\n  };\n}\n\nvar m = function (t) {\n  !function (e, t) {\n    if (\"function\" != typeof t && null !== t) throw new TypeError(\"Super expression must either be null or a function\");\n    e.prototype = Object.create(t && t.prototype, {\n      constructor: {\n        value: e,\n        writable: !0,\n        configurable: !0\n      }\n    }), t && c(e, t);\n  }(a, e);\n  var n,\n      o,\n      r,\n      u = l(a);\n\n  function a(e) {\n    var t;\n    if (function (e, t) {\n      if (!(e instanceof t)) throw new TypeError(\"Cannot call a class as a function\");\n    }(this, a), (t = u.call(this, e)).state = {\n      idle: !1,\n      oldDate: +new Date(),\n      lastActive: +new Date(),\n      remaining: null,\n      pageX: null,\n      pageY: null\n    }, t.tId = null, t.eventsBound = !1, e.debounce > 0 && e.throttle > 0) throw new Error(\"onAction can either be throttled or debounced (not both)\");\n    return e.debounce > 0 ? t._onAction = p(e.onAction, e.debounce) : e.throttle > 0 ? t._onAction = h(e.onAction, e.throttle) : e.onAction ? t._onAction = e.onAction : t._onAction = function () {}, e.eventsThrottle > 0 ? t._handleEvent = h(t._handleEvent.bind(s(t)), e.eventsThrottle) : t._handleEvent = t._handleEvent.bind(s(t)), e.startOnMount || (t.state.idle = !0), t._toggleIdleState = t._toggleIdleState.bind(s(t)), t.reset = t.reset.bind(s(t)), t.pause = t.pause.bind(s(t)), t.resume = t.resume.bind(s(t)), t.getRemainingTime = t.getRemainingTime.bind(s(t)), t.getElapsedTime = t.getElapsedTime.bind(s(t)), t.getLastActiveTime = t.getLastActiveTime.bind(s(t)), t.isIdle = t.isIdle.bind(s(t)), t;\n  }\n\n  return n = a, (o = [{\n    key: \"componentDidMount\",\n    value: function () {\n      this._bindEvents(), this.props.startOnMount && this.reset();\n    }\n  }, {\n    key: \"componentDidUpdate\",\n    value: function (e) {\n      e.debounce !== this.props.debounce && (this._onAction = p(this._onAction, this.props.debounce)), e.throttle !== this.props.throttle && (this._onAction = h(this._onAction, this.props.throttle)), e.eventsThrottle !== this.props.eventsThrottle && (this._handleEvent = h(this._handleEvent, this.props.eventsThrottle));\n    }\n  }, {\n    key: \"componentWillUnmount\",\n    value: function () {\n      clearTimeout(this.tId), this._unbindEvents(!0);\n    }\n  }, {\n    key: \"render\",\n    value: function () {\n      return this.props.children || null;\n    }\n  }, {\n    key: \"_bindEvents\",\n    value: function () {\n      var e = this;\n\n      if (d) {\n        var t = this.props,\n            n = t.element,\n            o = t.events,\n            r = t.passive,\n            i = t.capture;\n        this.eventsBound || (o.forEach(function (t) {\n          n.addEventListener(t, e._handleEvent, {\n            capture: i,\n            passive: r\n          });\n        }), this.eventsBound = !0);\n      }\n    }\n  }, {\n    key: \"_unbindEvents\",\n    value: function () {\n      var e = this,\n          t = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n\n      if (d) {\n        var n = this.props,\n            o = n.element,\n            r = n.events,\n            i = n.passive,\n            u = n.capture;\n        (this.eventsBound || t) && (r.forEach(function (t) {\n          o.removeEventListener(t, e._handleEvent, {\n            capture: u,\n            passive: i\n          });\n        }), this.eventsBound = !1);\n      }\n    }\n  }, {\n    key: \"_toggleIdleState\",\n    value: function (e) {\n      var t = this;\n      this.setState(function (e) {\n        return {\n          idle: !e.idle\n        };\n      }, function () {\n        var n = t.props,\n            o = n.onActive,\n            r = n.onIdle,\n            i = n.stopOnIdle;\n        t.state.idle ? (i && (clearTimeout(t.tId), t.tId = null, t._unbindEvents()), r(e)) : i || (t._bindEvents(), o(e));\n      });\n    }\n  }, {\n    key: \"_handleEvent\",\n    value: function (e) {\n      var t = this.state,\n          n = t.remaining,\n          o = t.pageX,\n          r = t.pageY,\n          i = t.idle,\n          u = this.props,\n          c = u.timeout,\n          s = u.stopOnIdle;\n\n      if (this._onAction(e), !n) {\n        if (\"mousemove\" === e.type) {\n          if (e.pageX === o && e.pageY === r) return;\n          if (void 0 === e.pageX && void 0 === e.pageY) return;\n          if (this.getElapsedTime() < 200) return;\n        }\n\n        clearTimeout(this.tId), this.tId = null;\n        var a = +new Date() - this.getLastActiveTime();\n        (i && !s || !i && a > c) && this._toggleIdleState(e), this.setState({\n          lastActive: +new Date(),\n          pageX: e.pageX,\n          pageY: e.pageY\n        }), i && s || (this.tId = setTimeout(this._toggleIdleState, c));\n      }\n    }\n  }, {\n    key: \"reset\",\n    value: function () {\n      clearTimeout(this.tId), this.tId = null, this._bindEvents(), this.setState({\n        idle: !1,\n        oldDate: +new Date(),\n        lastActive: +new Date(),\n        remaining: null\n      });\n      var e = this.props.timeout;\n      this.tId = setTimeout(this._toggleIdleState, e);\n    }\n  }, {\n    key: \"pause\",\n    value: function () {\n      null === this.state.remaining && (this._unbindEvents(), clearTimeout(this.tId), this.tId = null, this.setState({\n        remaining: this.getRemainingTime()\n      }));\n    }\n  }, {\n    key: \"resume\",\n    value: function () {\n      var e = this.state,\n          t = e.remaining,\n          n = e.idle;\n      null !== t && (this._bindEvents(), n || (this.tId = setTimeout(this._toggleIdleState, t), this.setState({\n        remaining: null,\n        lastActive: +new Date()\n      })));\n    }\n  }, {\n    key: \"getRemainingTime\",\n    value: function () {\n      var e = this.state,\n          t = e.remaining,\n          n = e.lastActive,\n          o = this.props.timeout;\n      if (null !== t) return t < 0 ? 0 : t;\n      var r = o - (+new Date() - n);\n      return r < 0 ? 0 : r;\n    }\n  }, {\n    key: \"getElapsedTime\",\n    value: function () {\n      var e = this.state.oldDate;\n      return +new Date() - e;\n    }\n  }, {\n    key: \"getLastActiveTime\",\n    value: function () {\n      return this.state.lastActive;\n    }\n  }, {\n    key: \"isIdle\",\n    value: function () {\n      return this.state.idle;\n    }\n  }]) && i(n.prototype, o), r && i(n, r), a;\n}();\n\nfunction b() {\n  var e = arguments.length > 0 && void 0 !== arguments[0] ? arguments[0] : {},\n      o = e.timeout,\n      r = void 0 === o ? 12e5 : o,\n      i = e.element,\n      u = void 0 === i ? f : i,\n      c = e.events,\n      s = void 0 === c ? v : c,\n      a = e.onIdle,\n      l = void 0 === a ? function () {} : a,\n      m = e.onActive,\n      b = void 0 === m ? function () {} : m,\n      g = e.onAction,\n      y = void 0 === g ? function () {} : g,\n      T = e.debounce,\n      w = void 0 === T ? 0 : T,\n      _ = e.throttle,\n      A = void 0 === _ ? 0 : _,\n      I = e.eventsThrottle,\n      E = void 0 === I ? 200 : I,\n      O = e.startOnMount,\n      D = void 0 === O || O,\n      S = e.stopOnIdle,\n      k = void 0 !== S && S,\n      M = e.capture,\n      R = void 0 === M || M,\n      j = e.passive,\n      P = void 0 === j || j,\n      L = t(!1),\n      X = t(!0),\n      Y = t(+new Date()),\n      B = t(+new Date()),\n      x = t(null),\n      U = t(null),\n      C = t(null),\n      W = t(null),\n      q = t(l),\n      z = t(b),\n      F = t(y),\n      G = function (e) {\n    var t = !X.current;\n    X.current = t, t ? (k && (clearTimeout(W.current), W.current = null, K()), q.current(e)) : k || (J(), z.current(e));\n  },\n      H = function (e) {\n    if (F.current(e), !x.current) {\n      if (\"mousemove\" === e.type) {\n        if (e.pageX === U && e.pageY === C) return;\n        if (void 0 === e.pageX && void 0 === e.pageY) return;\n        if (Q() < 200) return;\n      }\n\n      clearTimeout(W.current), W.current = null;\n      var t = +new Date() - V();\n      (X.current && !k || !X.current && t > r) && G(e), B.current = +new Date(), U.current = e.pageX, C.current = e.pageY, X.current && k || (W.current = setTimeout(G, r));\n    }\n  },\n      J = function () {\n    d && (L.current || (s.forEach(function (e) {\n      u.addEventListener(e, H, {\n        capture: R,\n        passive: P\n      });\n    }), L.current = !0));\n  },\n      K = function () {\n    var e = arguments.length > 0 && void 0 !== arguments[0] && arguments[0];\n    d && (L.current || e) && (s.forEach(function (e) {\n      u.removeEventListener(e, H, {\n        capture: R,\n        passive: P\n      });\n    }), L.current = !1);\n  },\n      N = function () {\n    if (null !== x.current) return x.current < 0 ? 0 : x.current;\n    var e = r - (+new Date() - B.current);\n    return e < 0 ? 0 : e;\n  },\n      Q = function () {\n    return +new Date() - Y.current;\n  },\n      V = function () {\n    return B.current;\n  },\n      Z = function () {\n    return X.current;\n  },\n      $ = function () {\n    clearTimeout(W.current), W.current = null, J(), X.current = !1, Y.current = +new Date(), B.current = +new Date(), x.current = null, W.current = setTimeout(G, r);\n  },\n      ee = function () {\n    null === x.current && (K(), clearTimeout(W.current), W.current = null, x.current = N());\n  },\n      te = function () {\n    null !== x.current && (J(), X.current || (W.current = setTimeout(G, x.current), x.current = null, B.current = +new Date()));\n  };\n\n  return n(function () {\n    if (w > 0 && A > 0) throw new Error(\"onAction can either be throttled or debounced (not both)\");\n    return E > 0 && (H = h(H, E)), J(), D && $(), function () {\n      clearTimeout(W.current), K(!0);\n    };\n  }, []), n(function () {\n    q.current = l;\n  }, [l]), n(function () {\n    z.current = b;\n  }, [b]), n(function () {\n    F.current = w > 0 ? p(y, w) : A > 0 ? h(y, A) : y;\n  }, [y]), {\n    isIdle: Z,\n    pause: ee,\n    reset: $,\n    resume: te,\n    getLastActiveTime: V,\n    getElapsedTime: Q,\n    getRemainingTime: N\n  };\n}\n\nm.propTypes = {\n  timeout: o.number,\n  events: o.arrayOf(o.string),\n  onIdle: o.func,\n  onActive: o.func,\n  onAction: o.func,\n  debounce: o.number,\n  throttle: o.number,\n  eventsThrottle: o.number,\n  element: o.oneOfType([o.object, o.element]),\n  startOnMount: o.bool,\n  stopOnIdle: o.bool,\n  passive: o.bool,\n  capture: o.bool\n}, m.defaultProps = {\n  timeout: 12e5,\n  element: f,\n  events: v,\n  onIdle: function () {},\n  onActive: function () {},\n  onAction: function () {},\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: !0,\n  stopOnIdle: !1,\n  capture: !0,\n  passive: !0\n}, b.propTypes = {\n  timeout: o.number,\n  events: o.arrayOf(o.string),\n  onIdle: o.func,\n  onActive: o.func,\n  onAction: o.func,\n  debounce: o.number,\n  throttle: o.number,\n  eventsThrottle: o.number,\n  element: o.oneOfType([o.object, o.element]),\n  startOnMount: o.bool,\n  stopOnIdle: o.bool,\n  passive: o.bool,\n  capture: o.bool\n}, b.defaultProps = {\n  timeout: 12e5,\n  element: f,\n  events: v,\n  onIdle: function () {},\n  onActive: function () {},\n  onAction: function () {},\n  debounce: 0,\n  throttle: 0,\n  eventsThrottle: 200,\n  startOnMount: !0,\n  stopOnIdle: !1,\n  capture: !0,\n  passive: !0\n};\nexport default m;\nexport { b as useIdleTimer };","map":null,"metadata":{},"sourceType":"module"}