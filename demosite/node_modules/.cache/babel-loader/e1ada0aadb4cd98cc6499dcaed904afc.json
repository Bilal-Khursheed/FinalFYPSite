{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst _require = require('stream'),\n      Readable = _require.Readable;\n\nconst sysPath = require('path');\n\nconst picomatch = require('picomatch');\n\nconst _require2 = require('util'),\n      promisify = _require2.promisify;\n\nconst _ref = [promisify(fs.readdir), promisify(fs.stat), promisify(fs.lstat)],\n      readdir = _ref[0],\n      stat = _ref[1],\n      lstat = _ref[2];\nconst supportsDirent = 'Dirent' in fs;\n/**\n * @typedef {Object} EntryInfo\n * @property {String} path\n * @property {String} fullPath\n * @property {fs.Stats=} stats\n * @property {fs.Dirent=} dirent\n * @property {String} basename\n */\n\nconst isWindows = process.platform === 'win32';\nconst supportsBigint = typeof BigInt === 'function';\nconst BANG = '!';\nconst NORMAL_FLOW_ERRORS = new Set(['ENOENT', 'EPERM', 'EACCES', 'ELOOP']);\nconst STAT_OPTIONS_SUPPORT_LENGTH = 3;\nconst FILE_TYPE = 'files';\nconst DIR_TYPE = 'directories';\nconst FILE_DIR_TYPE = 'files_directories';\nconst EVERYTHING_TYPE = 'all';\nconst FILE_TYPES = new Set([FILE_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);\nconst DIR_TYPES = new Set([DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE]);\nconst ALL_TYPES = [FILE_TYPE, DIR_TYPE, FILE_DIR_TYPE, EVERYTHING_TYPE];\n\nconst isNormalFlowError = errorCode => NORMAL_FLOW_ERRORS.has(errorCode);\n\nconst checkBasename = f => f(entry.basename);\n\nconst normalizeFilter = filter => {\n  if (filter === undefined) return;\n  if (typeof filter === 'function') return filter;\n\n  if (typeof filter === 'string') {\n    const glob = picomatch(filter.trim());\n    return entry => glob(entry.basename);\n  }\n\n  if (Array.isArray(filter)) {\n    const positive = [];\n    const negative = [];\n\n    for (const item of filter) {\n      const trimmed = item.trim();\n\n      if (trimmed.charAt(0) === BANG) {\n        negative.push(picomatch(trimmed.slice(1)));\n      } else {\n        positive.push(picomatch(trimmed));\n      }\n    }\n\n    if (negative.length > 0) {\n      if (positive.length > 0) {\n        return entry => positive.some(f => f(entry.basename)) && !negative.some(f => f(entry.basename));\n      } else {\n        return entry => !negative.some(f => f(entry.basename));\n      }\n    } else {\n      return entry => positive.some(f => f(entry.basename));\n    }\n  }\n};\n\nclass ExploringDir {\n  constructor(path, depth) {\n    this.path = path;\n    this.depth = depth;\n  }\n\n}\n\nclass ReaddirpStream extends Readable {\n  static get defaultOptions() {\n    return {\n      root: '.',\n      fileFilter: path => true,\n      directoryFilter: path => true,\n      type: 'files',\n      lstat: false,\n      depth: 2147483648,\n      alwaysStat: false\n    };\n  }\n\n  constructor(options = {}) {\n    super({\n      objectMode: true,\n      highWaterMark: 1,\n      autoDestroy: true\n    });\n    const opts = Object.assign({}, ReaddirpStream.defaultOptions, options);\n    const root = opts.root;\n    this._fileFilter = normalizeFilter(opts.fileFilter);\n    this._directoryFilter = normalizeFilter(opts.directoryFilter);\n    this._statMethod = opts.lstat ? lstat : stat;\n    this._statOpts = {\n      bigint: isWindows\n    };\n    this._maxDepth = opts.depth;\n    this._entryType = opts.type;\n    this._root = sysPath.resolve(root);\n    this._isDirent = !opts.alwaysStat && supportsDirent;\n    this._statsProp = this._isDirent ? 'dirent' : 'stats';\n    this._readdir_options = {\n      encoding: 'utf8',\n      withFileTypes: this._isDirent\n    }; // Launch stream with one parent, the root dir.\n\n    /** @type Array<[string, number]>  */\n\n    this.parents = [new ExploringDir(root, 0)];\n    this.filesToRead = 0;\n  }\n\n  async _read() {\n    do {\n      // If the stream was destroyed, we must not proceed.\n      if (this.destroyed) return;\n      const parent = this.parents.pop();\n\n      if (!parent) {\n        // ...we have files to process; but not directories.\n        // hence, parent is undefined; and we cannot execute fs.readdir().\n        // The files are being processed anywhere.\n        break;\n      }\n\n      await this._exploreDirectory(parent);\n    } while (!this.isPaused() && !this._isQueueEmpty());\n\n    this._endStreamIfQueueIsEmpty();\n  }\n\n  async _exploreDirectory(parent) {\n    /** @type Array<fs.Dirent|string> */\n    let files = []; // To prevent race conditions, we increase counter while awaiting readdir.\n\n    this.filesToRead++;\n\n    try {\n      files = await readdir(parent.path, this._readdir_options);\n    } catch (error) {\n      if (isNormalFlowError(error.code)) {\n        this._handleError(error);\n      } else {\n        this._handleFatalError(error);\n      }\n    }\n\n    this.filesToRead--; // If the stream was destroyed, after readdir is completed\n\n    if (this.destroyed) return;\n    this.filesToRead += files.length;\n    const entries = await Promise.all(files.map(dirent => this._formatEntry(dirent, parent)));\n    if (this.destroyed) return;\n\n    for (let i = 0; i < entries.length; i++) {\n      const entry = entries[i];\n      this.filesToRead--;\n\n      if (!entry) {\n        continue;\n      }\n\n      if (this._isDirAndMatchesFilter(entry)) {\n        this._pushNewParentIfLessThanMaxDepth(entry.fullPath, parent.depth + 1);\n\n        this._emitPushIfUserWantsDir(entry);\n      } else if (this._isFileAndMatchesFilter(entry)) {\n        this._emitPushIfUserWantsFile(entry);\n      }\n    }\n  }\n\n  _isStatOptionsSupported() {\n    return this._statMethod.length === STAT_OPTIONS_SUPPORT_LENGTH;\n  }\n\n  _stat(fullPath) {\n    if (isWindows && this._isStatOptionsSupported()) {\n      return this._statMethod(fullPath, this._statOpts);\n    } else {\n      return this._statMethod(fullPath);\n    }\n  }\n\n  async _formatEntry(dirent, parent) {\n    const basename = this._isDirent ? dirent.name : dirent;\n    const fullPath = sysPath.resolve(sysPath.join(parent.path, basename));\n    let stats;\n\n    if (this._isDirent) {\n      stats = dirent;\n    } else {\n      try {\n        stats = await this._stat(fullPath);\n      } catch (error) {\n        if (isNormalFlowError(error.code)) {\n          this._handleError(error);\n        } else {\n          this._handleFatalError(error);\n        }\n\n        return;\n      }\n    }\n\n    const path = sysPath.relative(this._root, fullPath);\n    /** @type {EntryInfo} */\n\n    const entry = {\n      path,\n      fullPath,\n      basename,\n      [this._statsProp]: stats\n    };\n    return entry;\n  }\n\n  _isQueueEmpty() {\n    return this.parents.length === 0 && this.filesToRead === 0 && this.readable;\n  }\n\n  _endStreamIfQueueIsEmpty() {\n    if (this._isQueueEmpty()) {\n      this.push(null);\n    }\n  }\n\n  _pushNewParentIfLessThanMaxDepth(parentPath, depth) {\n    if (depth <= this._maxDepth) {\n      this.parents.push(new ExploringDir(parentPath, depth));\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  _isDirAndMatchesFilter(entry) {\n    return entry[this._statsProp].isDirectory() && this._directoryFilter(entry);\n  }\n\n  _isFileAndMatchesFilter(entry) {\n    const stats = entry[this._statsProp];\n    const isFileType = this._entryType === EVERYTHING_TYPE && !stats.isDirectory() || stats.isFile() || stats.isSymbolicLink();\n    return isFileType && this._fileFilter(entry);\n  }\n\n  _emitPushIfUserWantsDir(entry) {\n    if (DIR_TYPES.has(this._entryType)) {\n      // TODO: Understand why this happens.\n      const fn = () => {\n        this.push(entry);\n      };\n\n      if (this._isDirent) setImmediate(fn);else fn();\n    }\n  }\n\n  _emitPushIfUserWantsFile(entry) {\n    if (FILE_TYPES.has(this._entryType)) {\n      this.push(entry);\n    }\n  }\n\n  _handleError(error) {\n    if (!this.destroyed) {\n      this.emit('warn', error);\n    }\n  }\n\n  _handleFatalError(error) {\n    this.destroy(error);\n  }\n\n}\n/**\n * @typedef {Object} ReaddirpArguments\n * @property {Function=} fileFilter\n * @property {Function=} directoryFilter\n * @property {String=} type\n * @property {Number=} depth\n * @property {String=} root\n * @property {Boolean=} lstat\n * @property {Boolean=} bigint\n */\n\n/**\n * Main function which ends up calling readdirRec and reads all files and directories in given root recursively.\n * @param {String} root Root directory\n * @param {ReaddirpArguments=} options Options to specify root (start directory), filters and recursion depth\n */\n\n\nconst readdirp = (root, options = {}) => {\n  let type = options['entryType'] || options.type;\n  if (type === 'both') type = FILE_DIR_TYPE; // backwards-compatibility\n\n  if (type) options.type = type;\n\n  if (root == null || typeof root === 'undefined') {\n    throw new Error('readdirp: root argument is required. Usage: readdirp(root, options)');\n  } else if (typeof root !== 'string') {\n    throw new Error(\"readdirp: root argument must be a string. Usage: readdirp(root, options)\");\n  } else if (type && !ALL_TYPES.includes(type)) {\n    throw new Error(\"readdirp: Invalid type passed. Use one of \".concat(ALL_TYPES.join(', ')));\n  }\n\n  options.root = root;\n  return new ReaddirpStream(options);\n};\n\nconst readdirpPromise = (root, options = {}) => {\n  return new Promise((resolve, reject) => {\n    const files = [];\n    readdirp(root, options).on('data', entry => files.push(entry)).on('end', () => resolve(files)).on('error', error => reject(error));\n  });\n};\n\nreaddirp.promise = readdirpPromise;\nreaddirp.ReaddirpStream = ReaddirpStream;\nreaddirp.default = readdirp;\nmodule.exports = readdirp;","map":null,"metadata":{},"sourceType":"script"}