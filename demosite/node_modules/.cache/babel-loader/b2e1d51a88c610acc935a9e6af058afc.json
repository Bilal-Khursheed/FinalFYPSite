{"ast":null,"code":"'use strict';\n\nconst fs = require('fs');\n\nconst sysPath = require('path');\n\nconst _require = require('util'),\n      promisify = _require.promisify;\n\nlet fsevents;\n\ntry {\n  fsevents = require('fsevents');\n} catch (error) {\n  if (process.env.CHOKIDAR_PRINT_FSEVENTS_REQUIRE_ERROR) console.error(error);\n}\n\nif (fsevents) {\n  // TODO: real check\n  const mtch = process.version.match(/v(\\d+)\\.(\\d+)/);\n\n  if (mtch && mtch[1] && mtch[2]) {\n    const maj = Number.parseInt(mtch[1], 10);\n    const min = Number.parseInt(mtch[2], 10);\n\n    if (maj === 8 && min < 16) {\n      fsevents = undefined;\n    }\n  }\n}\n\nconst _require2 = require('./constants'),\n      EV_ADD = _require2.EV_ADD,\n      EV_CHANGE = _require2.EV_CHANGE,\n      EV_ADD_DIR = _require2.EV_ADD_DIR,\n      EV_UNLINK = _require2.EV_UNLINK,\n      EV_ERROR = _require2.EV_ERROR,\n      STR_DATA = _require2.STR_DATA,\n      STR_END = _require2.STR_END,\n      FSEVENT_CREATED = _require2.FSEVENT_CREATED,\n      FSEVENT_MODIFIED = _require2.FSEVENT_MODIFIED,\n      FSEVENT_DELETED = _require2.FSEVENT_DELETED,\n      FSEVENT_MOVED = _require2.FSEVENT_MOVED,\n      FSEVENT_UNKNOWN = _require2.FSEVENT_UNKNOWN,\n      FSEVENT_TYPE_DIRECTORY = _require2.FSEVENT_TYPE_DIRECTORY,\n      FSEVENT_TYPE_SYMLINK = _require2.FSEVENT_TYPE_SYMLINK,\n      ROOT_GLOBSTAR = _require2.ROOT_GLOBSTAR,\n      DIR_SUFFIX = _require2.DIR_SUFFIX,\n      DOT_SLASH = _require2.DOT_SLASH,\n      FUNCTION_TYPE = _require2.FUNCTION_TYPE,\n      EMPTY_FN = _require2.EMPTY_FN,\n      IDENTITY_FN = _require2.IDENTITY_FN;\n\nconst FS_MODE_READ = 'r';\n\nconst Depth = value => isNaN(value) ? {} : {\n  depth: value\n};\n\nconst stat = promisify(fs.stat);\nconst open = promisify(fs.open);\nconst close = promisify(fs.close);\nconst lstat = promisify(fs.lstat);\nconst realpath = promisify(fs.realpath);\nconst statMethods = {\n  stat,\n  lstat\n};\n/**\n * @typedef {String} Path\n */\n\n/**\n * @typedef {Object} FsEventsWatchContainer\n * @property {Set<Function>} listeners\n * @property {Function} rawEmitter\n * @property {{stop: Function}} watcher\n */\n// fsevents instance helper functions\n\n/**\n * Object to hold per-process fsevents instances (may be shared across chokidar FSWatcher instances)\n * @type {Map<Path,FsEventsWatchContainer>}\n */\n\nconst FSEventsWatchers = new Map(); // Threshold of duplicate path prefixes at which to start\n// consolidating going forward\n\nconst consolidateThreshhold = 10;\nconst wrongEventFlags = new Set([69888, 70400, 71424, 72704, 73472, 131328, 131840, 262912]);\n/**\n * Instantiates the fsevents interface\n * @param {Path} path path to be watched\n * @param {Function} callback called when fsevents is bound and ready\n * @returns {{stop: Function}} new fsevents instance\n */\n\nconst createFSEventsInstance = (path, callback) => {\n  const stop = fsevents.watch(path, callback);\n  return {\n    stop\n  };\n};\n/**\n * Instantiates the fsevents interface or binds listeners to an existing one covering\n * the same file tree.\n * @param {Path} path           - to be watched\n * @param {Path} realPath       - real path for symlinks\n * @param {Function} listener   - called when fsevents emits events\n * @param {Function} rawEmitter - passes data to listeners of the 'raw' event\n * @returns {Function} closer\n */\n\n\nfunction setFSEventsListener(path, realPath, listener, rawEmitter, fsw) {\n  let watchPath = sysPath.extname(path) ? sysPath.dirname(path) : path;\n  const parentPath = sysPath.dirname(watchPath);\n  let cont = FSEventsWatchers.get(watchPath); // If we've accumulated a substantial number of paths that\n  // could have been consolidated by watching one directory\n  // above the current one, create a watcher on the parent\n  // path instead, so that we do consolidate going forward.\n\n  if (couldConsolidate(parentPath)) {\n    watchPath = parentPath;\n  }\n\n  const resolvedPath = sysPath.resolve(path);\n  const hasSymlink = resolvedPath !== realPath;\n\n  const filteredListener = (fullPath, flags, info) => {\n    if (hasSymlink) fullPath = fullPath.replace(realPath, resolvedPath);\n    if (fullPath === resolvedPath || !fullPath.indexOf(resolvedPath + sysPath.sep)) listener(fullPath, flags, info);\n  }; // check if there is already a watcher on a parent path\n  // modifies `watchPath` to the parent path when it finds a match\n\n\n  let watchedParent = false;\n\n  for (const watchedPath of FSEventsWatchers.keys()) {\n    if (realPath.indexOf(sysPath.resolve(watchedPath) + sysPath.sep) === 0) {\n      watchPath = watchedPath;\n      cont = FSEventsWatchers.get(watchPath);\n      watchedParent = true;\n      break;\n    }\n  }\n\n  if (cont || watchedParent) {\n    cont.listeners.add(filteredListener);\n  } else {\n    cont = {\n      listeners: new Set([filteredListener]),\n      rawEmitter,\n      watcher: createFSEventsInstance(watchPath, (fullPath, flags) => {\n        if (fsw.closed) return;\n        const info = fsevents.getInfo(fullPath, flags);\n        cont.listeners.forEach(list => {\n          list(fullPath, flags, info);\n        });\n        cont.rawEmitter(info.event, fullPath, info);\n      })\n    };\n    FSEventsWatchers.set(watchPath, cont);\n  } // removes this instance's listeners and closes the underlying fsevents\n  // instance if there are no more listeners left\n\n\n  return () => {\n    const lst = cont.listeners;\n    lst.delete(filteredListener);\n\n    if (!lst.size) {\n      FSEventsWatchers.delete(watchPath);\n      if (cont.watcher) return cont.watcher.stop().then(() => {\n        cont.rawEmitter = cont.watcher = undefined;\n        Object.freeze(cont);\n      });\n    }\n  };\n} // Decide whether or not we should start a new higher-level\n// parent watcher\n\n\nconst couldConsolidate = path => {\n  let count = 0;\n\n  for (const watchPath of FSEventsWatchers.keys()) {\n    if (watchPath.indexOf(path) === 0) {\n      count++;\n\n      if (count >= consolidateThreshhold) {\n        return true;\n      }\n    }\n  }\n\n  return false;\n}; // returns boolean indicating whether fsevents can be used\n\n\nconst canUse = () => fsevents && FSEventsWatchers.size < 128; // determines subdirectory traversal levels from root to path\n\n\nconst calcDepth = (path, root) => {\n  let i = 0;\n\n  while (!path.indexOf(root) && (path = sysPath.dirname(path)) !== root) i++;\n\n  return i;\n};\n/**\n * @mixin\n */\n\n\nclass FsEventsHandler {\n  /**\n   * @param {import('../index').FSWatcher} fsw\n   */\n  constructor(fsw) {\n    this.fsw = fsw;\n  }\n\n  checkIgnored(path, stats) {\n    const ipaths = this.fsw._ignoredPaths;\n\n    if (this.fsw._isIgnored(path, stats)) {\n      ipaths.add(path);\n\n      if (stats && stats.isDirectory()) {\n        ipaths.add(path + ROOT_GLOBSTAR);\n      }\n\n      return true;\n    }\n\n    ipaths.delete(path);\n    ipaths.delete(path + ROOT_GLOBSTAR);\n  }\n\n  addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    const event = watchedDir.has(item) ? EV_CHANGE : EV_ADD;\n    this.handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n  }\n\n  async checkFd(path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    try {\n      const fd = await open(path, FS_MODE_READ);\n      if (this.fsw.closed) return;\n      await close(fd);\n      if (this.fsw.closed) return;\n      this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n    } catch (error) {\n      if (error.code === 'EACCES') {\n        this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      } else {\n        this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n      }\n    }\n  }\n\n  handleEvent(event, path, fullPath, realPath, parent, watchedDir, item, info, opts) {\n    if (this.fsw.closed || this.checkIgnored(path)) return;\n\n    if (event === EV_UNLINK) {\n      // suppress unlink events on never before seen files\n      if (info.type === FSEVENT_TYPE_DIRECTORY || watchedDir.has(item)) {\n        this.fsw._remove(parent, item);\n      }\n    } else {\n      if (event === EV_ADD) {\n        // track new directories\n        if (info.type === FSEVENT_TYPE_DIRECTORY) this.fsw._getWatchedDir(path);\n\n        if (info.type === FSEVENT_TYPE_SYMLINK && opts.followSymlinks) {\n          // push symlinks back to the top of the stack to get handled\n          const curDepth = opts.depth === undefined ? undefined : calcDepth(fullPath, realPath) + 1;\n          return this._addToFsEvents(path, false, true, curDepth);\n        } // track new paths\n        // (other than symlinks being followed, which will be tracked soon)\n\n\n        this.fsw._getWatchedDir(parent).add(item);\n      }\n      /**\n       * @type {'add'|'addDir'|'unlink'|'unlinkDir'}\n       */\n\n\n      const eventName = info.type === FSEVENT_TYPE_DIRECTORY ? event + DIR_SUFFIX : event;\n\n      this.fsw._emit(eventName, path);\n\n      if (eventName === EV_ADD_DIR) this._addToFsEvents(path, false, true);\n    }\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} watchPath  - file/dir path to be watched with fsevents\n   * @param {String} realPath   - real path (in case of symlinks)\n   * @param {Function} transform  - path transformer\n   * @param {Function} globFilter - path filter in case a glob pattern was provided\n   * @returns {Function} closer for the watcher instance\n  */\n\n\n  _watchWithFsEvents(watchPath, realPath, transform, globFilter) {\n    if (this.fsw.closed) return;\n    if (this.fsw._isIgnored(watchPath)) return;\n    const opts = this.fsw.options;\n\n    const watchCallback = async (fullPath, flags, info) => {\n      if (this.fsw.closed) return;\n      if (opts.depth !== undefined && calcDepth(fullPath, realPath) > opts.depth) return;\n      const path = transform(sysPath.join(watchPath, sysPath.relative(watchPath, fullPath)));\n      if (globFilter && !globFilter(path)) return; // ensure directories are tracked\n\n      const parent = sysPath.dirname(path);\n      const item = sysPath.basename(path);\n\n      const watchedDir = this.fsw._getWatchedDir(info.type === FSEVENT_TYPE_DIRECTORY ? path : parent); // correct for wrong events emitted\n\n\n      if (wrongEventFlags.has(flags) || info.event === FSEVENT_UNKNOWN) {\n        if (typeof opts.ignored === FUNCTION_TYPE) {\n          let stats;\n\n          try {\n            stats = await stat(path);\n          } catch (error) {}\n\n          if (this.fsw.closed) return;\n          if (this.checkIgnored(path, stats)) return;\n\n          if (stats) {\n            this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          } else {\n            this.handleEvent(EV_UNLINK, path, fullPath, realPath, parent, watchedDir, item, info, opts);\n          }\n        } else {\n          this.checkFd(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      } else {\n        switch (info.event) {\n          case FSEVENT_CREATED:\n          case FSEVENT_MODIFIED:\n            return this.addOrChange(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n\n          case FSEVENT_DELETED:\n          case FSEVENT_MOVED:\n            return this.checkFd(path, fullPath, realPath, parent, watchedDir, item, info, opts);\n        }\n      }\n    };\n\n    const closer = setFSEventsListener(watchPath, realPath, watchCallback, this.fsw._emitRaw, this.fsw);\n\n    this.fsw._emitReady();\n\n    return closer;\n  }\n  /**\n   * Handle symlinks encountered during directory scan\n   * @param {String} linkPath path to symlink\n   * @param {String} fullPath absolute path to the symlink\n   * @param {Function} transform pre-existing path transformer\n   * @param {Number} curDepth level of subdirectories traversed to where symlink is\n   * @returns {Promise<void>}\n   */\n\n\n  async _handleFsEventsSymlink(linkPath, fullPath, transform, curDepth) {\n    // don't follow the same symlink more than once\n    if (this.fsw.closed || this.fsw._symlinkPaths.has(fullPath)) return;\n\n    this.fsw._symlinkPaths.set(fullPath, true);\n\n    this.fsw._incrReadyCount();\n\n    try {\n      const linkTarget = await realpath(linkPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(linkTarget)) {\n        return this.fsw._emitReady();\n      }\n\n      this.fsw._incrReadyCount(); // add the linkTarget for watching with a wrapper for transform\n      // that causes emitted paths to incorporate the link's path\n\n\n      this._addToFsEvents(linkTarget || linkPath, path => {\n        let aliasedPath = linkPath;\n\n        if (linkTarget && linkTarget !== DOT_SLASH) {\n          aliasedPath = path.replace(linkTarget, linkPath);\n        } else if (path !== DOT_SLASH) {\n          aliasedPath = sysPath.join(linkPath, path);\n        }\n\n        return transform(aliasedPath);\n      }, false, curDepth);\n    } catch (error) {\n      if (this.fsw._handleError(error)) {\n        return this.fsw._emitReady();\n      }\n    }\n  }\n  /**\n   *\n   * @param {Path} newPath\n   * @param {fs.Stats} stats\n   */\n\n\n  emitAdd(newPath, stats, processPath, opts, forceAdd) {\n    const pp = processPath(newPath);\n    const isDir = stats.isDirectory();\n\n    const dirObj = this.fsw._getWatchedDir(sysPath.dirname(pp));\n\n    const base = sysPath.basename(pp); // ensure empty dirs get tracked\n\n    if (isDir) this.fsw._getWatchedDir(pp);\n    if (dirObj.has(base)) return;\n    dirObj.add(base);\n\n    if (!opts.ignoreInitial || forceAdd === true) {\n      this.fsw._emit(isDir ? EV_ADD_DIR : EV_ADD, pp, stats);\n    }\n  }\n\n  initWatch(realPath, path, wh, processPath) {\n    if (this.fsw.closed) return;\n\n    const closer = this._watchWithFsEvents(wh.watchPath, sysPath.resolve(realPath || wh.watchPath), processPath, wh.globFilter);\n\n    this.fsw._addPathCloser(path, closer);\n  }\n  /**\n   * Handle added path with fsevents\n   * @param {String} path file/dir path or glob pattern\n   * @param {Function|Boolean=} transform converts working path to what the user expects\n   * @param {Boolean=} forceAdd ensure add is emitted\n   * @param {Number=} priorDepth Level of subdirectories already traversed.\n   * @returns {Promise<void>}\n   */\n\n\n  async _addToFsEvents(path, transform, forceAdd, priorDepth) {\n    if (this.fsw.closed) {\n      return;\n    }\n\n    const opts = this.fsw.options;\n    const processPath = typeof transform === FUNCTION_TYPE ? transform : IDENTITY_FN;\n\n    const wh = this.fsw._getWatchHelpers(path); // evaluate what is at the path we're being asked to watch\n\n\n    try {\n      const stats = await statMethods[wh.statMethod](wh.watchPath);\n      if (this.fsw.closed) return;\n\n      if (this.fsw._isIgnored(wh.watchPath, stats)) {\n        throw null;\n      }\n\n      if (stats.isDirectory()) {\n        // emit addDir unless this is a glob parent\n        if (!wh.globFilter) this.emitAdd(processPath(path), stats, processPath, opts, forceAdd); // don't recurse further if it would exceed depth setting\n\n        if (priorDepth && priorDepth > opts.depth) return; // scan the contents of the dir\n\n        this.fsw._readdirp(wh.watchPath, {\n          fileFilter: entry => wh.filterPath(entry),\n          directoryFilter: entry => wh.filterDir(entry),\n          ...Depth(opts.depth - (priorDepth || 0))\n        }).on(STR_DATA, entry => {\n          // need to check filterPath on dirs b/c filterDir is less restrictive\n          if (this.fsw.closed) {\n            return;\n          }\n\n          if (entry.stats.isDirectory() && !wh.filterPath(entry)) return;\n          const joinedPath = sysPath.join(wh.watchPath, entry.path);\n          const fullPath = entry.fullPath;\n\n          if (wh.followSymlinks && entry.stats.isSymbolicLink()) {\n            // preserve the current depth here since it can't be derived from\n            // real paths past the symlink\n            const curDepth = opts.depth === undefined ? undefined : calcDepth(joinedPath, sysPath.resolve(wh.watchPath)) + 1;\n\n            this._handleFsEventsSymlink(joinedPath, fullPath, processPath, curDepth);\n          } else {\n            this.emitAdd(joinedPath, entry.stats, processPath, opts, forceAdd);\n          }\n        }).on(EV_ERROR, EMPTY_FN).on(STR_END, () => {\n          this.fsw._emitReady();\n        });\n      } else {\n        this.emitAdd(wh.watchPath, stats, processPath, opts, forceAdd);\n\n        this.fsw._emitReady();\n      }\n    } catch (error) {\n      if (!error || this.fsw._handleError(error)) {\n        // TODO: Strange thing: \"should not choke on an ignored watch path\" will be failed without 2 ready calls -__-\n        this.fsw._emitReady();\n\n        this.fsw._emitReady();\n      }\n    }\n\n    if (opts.persistent && forceAdd !== true) {\n      if (typeof transform === FUNCTION_TYPE) {\n        // realpath has already been resolved\n        this.initWatch(undefined, path, wh, processPath);\n      } else {\n        let realPath;\n\n        try {\n          realPath = await realpath(wh.watchPath);\n        } catch (e) {}\n\n        this.initWatch(realPath, path, wh, processPath);\n      }\n    }\n  }\n\n}\n\nmodule.exports = FsEventsHandler;\nmodule.exports.canUse = canUse;","map":null,"metadata":{},"sourceType":"script"}