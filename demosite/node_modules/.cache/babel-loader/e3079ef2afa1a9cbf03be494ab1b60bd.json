{"ast":null,"code":"var colour = require('./colour');\n\nvar bus = require('./bus');\n\nvar required = false;\nvar useColours = true;\nvar coding = {\n  log: 'black',\n  info: 'yellow',\n  status: 'green',\n  detail: 'yellow',\n  fail: 'red',\n  error: 'red'\n};\n\nfunction log(type, text) {\n  var msg = '[nodemon] ' + (text || '');\n\n  if (useColours) {\n    msg = colour(coding[type], msg);\n  } // always push the message through our bus, using nextTick\n  // to help testing and get _out of_ promises.\n\n\n  process.nextTick(() => {\n    bus.emit('log', {\n      type: type,\n      message: text,\n      colour: msg\n    });\n  }); // but if we're running on the command line, also echo out\n  // question: should we actually just consume our own events?\n\n  if (!required) {\n    if (type === 'error') {\n      console.error(msg);\n    } else {\n      console.log(msg || '');\n    }\n  }\n}\n\nvar Logger = function (r) {\n  if (!(this instanceof Logger)) {\n    return new Logger(r);\n  }\n\n  this.required(r);\n  return this;\n};\n\nObject.keys(coding).forEach(function (type) {\n  Logger.prototype[type] = log.bind(null, type);\n}); // detail is for messages that are turned on during debug\n\nLogger.prototype.detail = function (msg) {\n  if (this.debug) {\n    log('detail', msg);\n  }\n};\n\nLogger.prototype.required = function (val) {\n  required = val;\n};\n\nLogger.prototype.debug = false;\n\nLogger.prototype._log = function (type, msg) {\n  if (required) {\n    bus.emit('log', {\n      type: type,\n      message: msg || '',\n      colour: msg || ''\n    });\n  } else if (type === 'error') {\n    console.error(msg);\n  } else {\n    console.log(msg || '');\n  }\n};\n\nObject.defineProperty(Logger.prototype, 'useColours', {\n  set: function (val) {\n    useColours = val;\n  },\n  get: function () {\n    return useColours;\n  }\n});\nmodule.exports = Logger;","map":null,"metadata":{},"sourceType":"script"}