{"ast":null,"code":"/**\n * Manages the internal config of nodemon, checking for the state of support\n * with fs.watch, how nodemon can watch files (using find or fs methods).\n *\n * This is *not* the user's config.\n */\nvar debug = require('debug')('nodemon');\n\nvar load = require('./load');\n\nvar rules = require('../rules');\n\nvar utils = require('../utils');\n\nvar pinVersion = require('../version').pin;\n\nvar command = require('./command');\n\nvar rulesToMonitor = require('../monitor/match').rulesToMonitor;\n\nvar bus = utils.bus;\n\nfunction reset() {\n  rules.reset();\n  config.dirs = [];\n  config.options = {\n    ignore: [],\n    watch: []\n  };\n  config.lastStarted = 0;\n  config.loaded = [];\n}\n\nvar config = {\n  run: false,\n  system: {\n    cwd: process.cwd()\n  },\n  required: false,\n  dirs: [],\n  timeout: 1000,\n  options: {}\n};\n/**\n * Take user defined settings, then detect the local machine capability, then\n * look for local and global nodemon.json files and merge together the final\n * settings with the config for nodemon.\n *\n * @param  {Object} settings user defined settings for nodemon (typically on\n *  the cli)\n * @param  {Function} ready callback fired once the config is loaded\n */\n\nconfig.load = function (settings, ready) {\n  reset();\n  var config = this;\n  load(settings, config.options, config, function (options) {\n    config.options = options;\n\n    if (options.watch.length === 0) {\n      // this is to catch when the watch is left blank\n      options.watch.push('*.*');\n    }\n\n    if (options['watch_interval']) {\n      // jshint ignore:line\n      options.watchInterval = options['watch_interval']; // jshint ignore:line\n    }\n\n    config.watchInterval = options.watchInterval || null;\n\n    if (options.signal) {\n      config.signal = options.signal;\n    }\n\n    var cmd = command(config.options);\n    config.command = {\n      raw: cmd,\n      string: utils.stringify(cmd.executable, cmd.args)\n    }; // now run automatic checks on system adding to the config object\n\n    options.monitor = rulesToMonitor(options.watch, options.ignore, config);\n    var cwd = process.cwd();\n    debug('config: dirs', config.dirs);\n\n    if (config.dirs.length === 0) {\n      config.dirs.unshift(cwd);\n    }\n\n    bus.emit('config:update', config);\n    pinVersion().then(function () {\n      ready(config);\n    }).catch(e => {\n      // this doesn't help testing, but does give exposure on syntax errors\n      console.error(e.stack);\n      setTimeout(() => {\n        throw e;\n      }, 0);\n    });\n  });\n};\n\nconfig.reset = reset;\nmodule.exports = config;","map":null,"metadata":{},"sourceType":"script"}