{"ast":null,"code":"/*\n\nnodemon is a utility for node, and replaces the use of the executable\nnode. So the user calls `nodemon foo.js` instead.\n\nnodemon can be run in a number of ways:\n\n`nodemon` - tries to use package.json#main property to run\n`nodemon` - if no package, looks for index.js\n`nodemon app.js` - runs app.js\n`nodemon --arg app.js --apparg` - eats arg1, and runs app.js with apparg\n`nodemon --apparg` - as above, but passes apparg to package.json#main (or\n  index.js)\n`nodemon --debug app.js\n\n*/\nvar fs = require('fs');\n\nvar path = require('path');\n\nvar existsSync = fs.existsSync || path.existsSync;\nmodule.exports = parse;\n/**\n * Parses the command line arguments `process.argv` and returns the\n * nodemon options, the user script and the executable script.\n *\n * @param  {Array} full process arguments, including `node` leading arg\n * @return {Object} { options, script, args }\n */\n\nfunction parse(argv) {\n  if (typeof argv === 'string') {\n    argv = argv.split(' ');\n  }\n\n  var eat = function (i, args) {\n    if (i <= args.length) {\n      return args.splice(i + 1, 1).pop();\n    }\n  };\n\n  var args = argv.slice(2);\n  var script = null;\n  var nodemonOptions = {\n    scriptPosition: null\n  };\n  var nodemonOpt = nodemonOption.bind(null, nodemonOptions);\n  var lookForArgs = true; // move forward through the arguments\n\n  for (var i = 0; i < args.length; i++) {\n    // if the argument looks like a file, then stop eating\n    if (!script) {\n      if (args[i] === '.' || existsSync(args[i])) {\n        script = args.splice(i, 1).pop(); // we capture the position of the script because we'll reinsert it in\n        // the right place in run.js:command (though I'm not sure we should even\n        // take it out of the array in the first place, but this solves passing\n        // arguments to the exec process for now).\n\n        nodemonOptions.scriptPosition = i;\n        i--;\n        continue;\n      }\n    }\n\n    if (lookForArgs) {\n      // respect the standard way of saying: hereafter belongs to my script\n      if (args[i] === '--') {\n        args.splice(i, 1);\n        nodemonOptions.scriptPosition = i; // cycle back one argument, as we just ate this one up\n\n        i--; // ignore all further nodemon arguments\n\n        lookForArgs = false; // move to the next iteration\n\n        continue;\n      }\n\n      if (nodemonOpt(args[i], eat.bind(null, i, args)) !== false) {\n        args.splice(i, 1); // cycle back one argument, as we just ate this one up\n\n        i--;\n      }\n    }\n  }\n\n  nodemonOptions.script = script;\n  nodemonOptions.args = args;\n  return nodemonOptions;\n}\n/**\n * Given an argument (ie. from process.argv), sets nodemon\n * options and can eat up the argument value\n *\n * @param {Object} options object that will be updated\n * @param {Sting} current argument from argv\n * @param {Function} the callback to eat up the next argument in argv\n * @return {Boolean} false if argument was not a nodemon arg\n */\n\n\nfunction nodemonOption(options, arg, eatNext) {\n  // line separation on purpose to help legibility\n  if (arg === '--help' || arg === '-h' || arg === '-?') {\n    var help = eatNext();\n    options.help = help ? help : true;\n  } else if (arg === '--version' || arg === '-v') {\n    options.version = true;\n  } else if (arg === '--no-update-notifier') {\n    options.noUpdateNotifier = true;\n  } else if (arg === '--spawn') {\n    options.spawn = true;\n  } else if (arg === '--dump') {\n    options.dump = true;\n  } else if (arg === '--verbose' || arg === '-V') {\n    options.verbose = true;\n  } else if (arg === '--legacy-watch' || arg === '-L') {\n    options.legacyWatch = true;\n  } else if (arg === '--polling-interval' || arg === '-P') {\n    options.pollingInterval = parseInt(eatNext(), 10);\n  } else // Depricated as this is \"on\" by default\n    if (arg === '--js') {\n      options.js = true;\n    } else if (arg === '--quiet' || arg === '-q') {\n      options.quiet = true;\n    } else if (arg === '--config') {\n      options.configFile = eatNext();\n    } else if (arg === '--watch' || arg === '-w') {\n      if (!options.watch) {\n        options.watch = [];\n      }\n\n      options.watch.push(eatNext());\n    } else if (arg === '--ignore' || arg === '-i') {\n      if (!options.ignore) {\n        options.ignore = [];\n      }\n\n      options.ignore.push(eatNext());\n    } else if (arg === '--exitcrash') {\n      options.exitcrash = true;\n    } else if (arg === '--delay' || arg === '-d') {\n      options.delay = parseDelay(eatNext());\n    } else if (arg === '--exec' || arg === '-x') {\n      options.exec = eatNext();\n    } else if (arg === '--no-stdin' || arg === '-I') {\n      options.stdin = false;\n    } else if (arg === '--on-change-only' || arg === '-C') {\n      options.runOnChangeOnly = true;\n    } else if (arg === '--ext' || arg === '-e') {\n      options.ext = eatNext();\n    } else if (arg === '--no-colours' || arg === '--no-colors') {\n      options.colours = false;\n    } else if (arg === '--signal' || arg === '-s') {\n      options.signal = eatNext();\n    } else if (arg === '--cwd') {\n      options.cwd = eatNext(); // go ahead and change directory. This is primarily for nodemon tools like\n      // grunt-nodemon - we're doing this early because it will affect where the\n      // user script is searched for.\n\n      process.chdir(path.resolve(options.cwd));\n    } else {\n      // this means we didn't match\n      return false;\n    }\n}\n/**\n * Given an argument (ie. from nodemonOption()), will parse and return the\n * equivalent millisecond value or 0 if the argument cannot be parsed\n *\n * @param {String} argument value given to the --delay option\n * @return {Number} millisecond equivalent of the argument\n */\n\n\nfunction parseDelay(value) {\n  var millisPerSecond = 1000;\n  var millis = 0;\n\n  if (value.match(/^\\d*ms$/)) {\n    // Explicitly parse for milliseconds when using ms time specifier\n    millis = parseInt(value, 10);\n  } else {\n    // Otherwise, parse for seconds, with or without time specifier then convert\n    millis = parseFloat(value) * millisPerSecond;\n  }\n\n  return isNaN(millis) ? 0 : millis;\n}","map":null,"metadata":{},"sourceType":"script"}